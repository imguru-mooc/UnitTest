# 🔴🟢🔵 TDD (Test-Driven Development) 따라하기 실습 (상세 버전)

## Red-Green-Refactor 사이클, 테스트 먼저 작성하는 개발 방법

> **실습 환경**: Visual Studio 2017 / 2019 / 2022  
> **테스트 프레임워크**: NUnit 3.x  
> **예상 소요 시간**: 약 150분

---

## 📋 목차

- Part 1: TDD 개념 이해 (Step 1-12)
- Part 2: 환경 설정 (Step 13-16)
- Part 3: 첫 번째 TDD 사이클 - 덧셈 (Step 17-26)
- Part 4: 두 번째 TDD 사이클 - 뺄셈 (Step 27-33)
- Part 5: 세 번째 TDD 사이클 - 나눗셈과 예외 (Step 34-42)
- Part 6: 실전 TDD - 문자열 계산기 (Step 43-55)
- Part 7: 실전 TDD - 로그인 서비스 (Step 56-68)
- Part 8: TDD 안티패턴과 베스트 프랙티스 (Step 69-75)
- Part 9: 종합 실습 - 장바구니 시스템 (Step 76-88)
- Part 10: 정리 및 다음 단계 (Step 89-95)

---

# Part 1: TDD 개념 이해

---

## 1. TDD란?

### Step 1.1: TDD의 정의

```
┌────────────────────────────────────────────────────────────────┐
│  TDD (Test-Driven Development)                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  "테스트 주도 개발"                                            │
│                                                                │
│  테스트를 먼저 작성하고, 그 테스트를 통과하는 코드를           │
│  나중에 작성하는 개발 방법론                                   │
│                                                                │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                                                         │  │
│  │   일반적인 개발:  코드 작성 → 테스트 작성              │  │
│  │                                                         │  │
│  │   TDD:           테스트 작성 → 코드 작성              │  │
│  │                       ↑                                 │  │
│  │                  테스트가 먼저!                        │  │
│  │                                                         │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                │
│  Kent Beck이 1999년 XP(Extreme Programming)에서 소개          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 1.2: TDD의 핵심 철학

```
┌────────────────────────────────────────────────────────────────┐
│  TDD의 핵심 철학                                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  "테스트가 통과하지 않으면 프로덕션 코드를 작성하지 않는다"    │
│                                                                │
│  원칙:                                                         │
│  1. 실패하는 테스트 없이는 새 코드를 작성하지 않는다          │
│  2. 테스트가 통과하면 바로 리팩토링한다                       │
│  3. 한 번에 하나의 테스트만 작성한다                          │
│                                                                │
│  목표:                                                         │
│  • 깨끗하고 동작하는 코드 (Clean code that works)             │
│  • 자신감 있는 코드 변경                                       │
│  • 지속적인 설계 개선                                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 2. Red-Green-Refactor 사이클

### Step 2.1: 사이클 개요

```
┌────────────────────────────────────────────────────────────────┐
│  Red-Green-Refactor 사이클                                     │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│              ┌─────────────┐                                   │
│              │             │                                   │
│              │   🔴 RED    │  ← 1. 실패하는 테스트 작성        │
│              │             │                                   │
│              └──────┬──────┘                                   │
│                     │                                          │
│                     ▼                                          │
│              ┌─────────────┐                                   │
│              │             │                                   │
│              │  🟢 GREEN   │  ← 2. 테스트 통과하는 코드 작성   │
│              │             │                                   │
│              └──────┬──────┘                                   │
│                     │                                          │
│                     ▼                                          │
│              ┌─────────────┐                                   │
│              │             │                                   │
│              │ 🔵 REFACTOR │  ← 3. 코드 개선 (리팩토링)        │
│              │             │                                   │
│              └──────┬──────┘                                   │
│                     │                                          │
│                     └─────────────────┐                        │
│                                       │                        │
│              ┌────────────────────────┘                        │
│              │                                                 │
│              ▼                                                 │
│         다음 기능으로...                                       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 2.2: 각 단계 상세 설명

```
┌────────────────────────────────────────────────────────────────┐
│  🔴 RED 단계 - 실패하는 테스트 작성                            │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  목표: 구현할 기능을 정의하는 테스트 작성                      │
│                                                                │
│  규칙:                                                         │
│  • 아직 존재하지 않는 코드에 대한 테스트 작성                  │
│  • 테스트는 반드시 실패해야 함 (빨간색)                        │
│  • 한 번에 하나의 테스트만 작성                                │
│  • 가장 간단한 케이스부터 시작                                 │
│                                                                │
│  이 단계에서 하는 일:                                          │
│  [Test]                                                        │
│  public void Add_TwoNumbers_ReturnsSum()                       │
│  {                                                             │
│      var calc = new Calculator();  // 아직 없는 클래스!        │
│      var result = calc.Add(2, 3);  // 아직 없는 메서드!        │
│      Assert.AreEqual(5, result);                               │
│  }                                                             │
│                                                                │
│  → 컴파일 에러 또는 테스트 실패 (RED)                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

```
┌────────────────────────────────────────────────────────────────┐
│  🟢 GREEN 단계 - 테스트 통과하는 코드 작성                     │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  목표: 테스트를 통과하는 가장 간단한 코드 작성                 │
│                                                                │
│  규칙:                                                         │
│  • 테스트를 통과하기 위한 최소한의 코드만 작성                 │
│  • 완벽함보다 동작을 우선                                      │
│  • "일단 동작하게" 만들기                                      │
│  • 하드코딩도 괜찮음!                                          │
│                                                                │
│  이 단계에서 하는 일:                                          │
│  public class Calculator                                       │
│  {                                                             │
│      public int Add(int a, int b)                              │
│      {                                                         │
│          return a + b;  // 테스트 통과를 위한 최소 코드        │
│      }                                                         │
│  }                                                             │
│                                                                │
│  → 테스트 통과 (GREEN)                                         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

```
┌────────────────────────────────────────────────────────────────┐
│  🔵 REFACTOR 단계 - 코드 개선                                  │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  목표: 중복 제거, 코드 품질 개선                               │
│                                                                │
│  규칙:                                                         │
│  • 테스트가 계속 통과하는 상태 유지                            │
│  • 중복 코드 제거                                              │
│  • 변수/메서드 이름 개선                                       │
│  • 설계 개선                                                   │
│  • 작은 단위로 리팩토링                                        │
│                                                                │
│  이 단계에서 하는 일:                                          │
│  • 변수명 개선                                                 │
│  • 메서드 추출                                                 │
│  • 클래스 분리                                                 │
│  • 상수 추출                                                   │
│                                                                │
│  주의: 리팩토링 후 반드시 테스트 실행!                         │
│        테스트가 깨지면 리팩토링 롤백                           │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 3. TDD vs 전통적 개발

### Step 3.1: 개발 방식 비교

```
┌────────────────────────────────────────────────────────────────┐
│  전통적 개발 방식                                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 요구사항 분석                                              │
│         ↓                                                      │
│  2. 설계                                                       │
│         ↓                                                      │
│  3. 코드 작성 ◄─── 먼저!                                      │
│         ↓                                                      │
│  4. 테스트 작성 (또는 수동 테스트)                             │
│         ↓                                                      │
│  5. 버그 수정                                                  │
│         ↓                                                      │
│  6. 배포                                                       │
│                                                                │
│  문제점:                                                       │
│  • 테스트가 나중에 작성되거나 생략됨                          │
│  • 테스트하기 어려운 코드 구조가 됨                           │
│  • 버그가 나중에 발견됨 (수정 비용 높음)                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

```
┌────────────────────────────────────────────────────────────────┐
│  TDD 개발 방식                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 요구사항 분석 (작은 단위로 분해)                          │
│         ↓                                                      │
│  ┌─────────────────────────────────────────┐                  │
│  │  2. 🔴 테스트 작성 ◄─── 먼저!          │                  │
│  │         ↓                               │                  │
│  │  3. 🟢 코드 작성 (최소한)              │  반복!           │
│  │         ↓                               │                  │
│  │  4. 🔵 리팩토링                        │                  │
│  └─────────────────────────────────────────┘                  │
│         ↓                                                      │
│  5. 배포                                                       │
│                                                                │
│  장점:                                                         │
│  • 테스트가 항상 존재                                         │
│  • 테스트하기 쉬운 코드 구조                                  │
│  • 버그가 즉시 발견됨 (수정 비용 낮음)                        │
│  • 코드에 대한 자신감                                         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 3.2: 비교표

| 항목 | 전통적 개발 | TDD |
|------|------------|-----|
| 테스트 시점 | 코드 작성 후 | 코드 작성 전 |
| 테스트 커버리지 | 낮음~중간 | 높음 (거의 100%) |
| 버그 발견 시점 | 늦음 | 즉시 |
| 리팩토링 두려움 | 높음 | 낮음 |
| 설계 품질 | 가변적 | 일반적으로 높음 |
| 초기 개발 속도 | 빠름 | 느림 |
| 장기 유지보수 | 어려움 | 쉬움 |

---

## 4. TDD의 장점

### Step 4.1: TDD의 장점들

```
┌────────────────────────────────────────────────────────────────┐
│  TDD의 장점                                                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 높은 코드 품질                                             │
│     • 테스트 가능한 설계 = 좋은 설계                          │
│     • 낮은 결합도, 높은 응집도                                │
│                                                                │
│  2. 버그 조기 발견                                             │
│     • 코드 작성 직후 바로 테스트                              │
│     • 버그 수정 비용 최소화                                   │
│                                                                │
│  3. 자신감 있는 리팩토링                                       │
│     • 테스트가 안전망 역할                                    │
│     • 과감한 코드 개선 가능                                   │
│                                                                │
│  4. 살아있는 문서                                              │
│     • 테스트 코드가 사용법 문서 역할                          │
│     • 항상 최신 상태 유지                                     │
│                                                                │
│  5. 집중력 향상                                                │
│     • 한 번에 하나의 기능에 집중                              │
│     • 작은 단위로 진행                                        │
│                                                                │
│  6. 심리적 안정                                                │
│     • "내 코드가 동작한다"는 확신                             │
│     • 배포에 대한 두려움 감소                                 │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 5. TDD의 단점과 오해

### Step 5.1: TDD의 단점

```
┌────────────────────────────────────────────────────────────────┐
│  TDD의 단점 (현실적인 고려사항)                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 초기 학습 곡선                                             │
│     • TDD 방식에 익숙해지는 데 시간 필요                      │
│     • 처음에는 생산성이 떨어질 수 있음                        │
│                                                                │
│  2. 초기 개발 시간 증가                                        │
│     • 테스트 코드 작성 시간 추가                              │
│     • 단, 장기적으로는 시간 절약                              │
│                                                                │
│  3. 테스트 유지보수 비용                                       │
│     • 요구사항 변경 시 테스트도 수정 필요                     │
│     • 잘못된 테스트는 오히려 방해                             │
│                                                                │
│  4. 모든 상황에 적합하지 않음                                  │
│     • 탐색적 프로토타이핑                                     │
│     • UI 테스트 (어려움)                                      │
│     • 레거시 코드 (점진적 적용 필요)                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 5.2: TDD에 대한 오해

```
┌────────────────────────────────────────────────────────────────┐
│  TDD에 대한 흔한 오해                                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ❌ 오해 1: "TDD하면 버그가 없다"                              │
│  ✅ 진실: 버그가 줄지만, 완전히 없앨 수는 없음                │
│                                                                │
│  ❌ 오해 2: "TDD는 무조건 느리다"                              │
│  ✅ 진실: 초기에는 느리지만, 장기적으로 빨라짐                │
│                                                                │
│  ❌ 오해 3: "100% 커버리지가 목표"                             │
│  ✅ 진실: 의미 있는 테스트가 목표, 숫자가 아님                │
│                                                                │
│  ❌ 오해 4: "TDD는 설계를 대체한다"                            │
│  ✅ 진실: TDD는 설계를 돕는 도구, 대체하지 않음               │
│                                                                │
│  ❌ 오해 5: "모든 코드에 TDD 적용해야 한다"                    │
│  ✅ 진실: 상황에 맞게 선택적으로 적용                         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 6. TDD의 세 가지 법칙

### Step 6.1: Uncle Bob의 세 가지 법칙

```
┌────────────────────────────────────────────────────────────────┐
│  TDD의 세 가지 법칙 (Robert C. Martin)                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  법칙 1:                                                       │
│  ─────────────────────────────────────────────────────────────│
│  "실패하는 단위 테스트를 작성하기 전에는                       │
│   프로덕션 코드를 작성하지 않는다"                             │
│                                                                │
│  → 테스트 없이 코드 작성 금지!                                 │
│                                                                │
│  법칙 2:                                                       │
│  ─────────────────────────────────────────────────────────────│
│  "컴파일이 실패하지 않으면서 실패하는 단위 테스트를            │
│   작성할 수 있을 만큼만 단위 테스트를 작성한다"                │
│                                                                │
│  → 테스트도 한 번에 조금씩만!                                  │
│                                                                │
│  법칙 3:                                                       │
│  ─────────────────────────────────────────────────────────────│
│  "현재 실패하는 테스트를 통과할 정도로만                       │
│   프로덕션 코드를 작성한다"                                    │
│                                                                │
│  → 테스트 통과에 필요한 최소한의 코드만!                       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 7. 좋은 테스트의 특성 (FIRST)

### Step 7.1: FIRST 원칙

```
┌────────────────────────────────────────────────────────────────┐
│  FIRST 원칙 - 좋은 테스트의 특성                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  F - Fast (빠름)                                               │
│  ─────────────────────────────────────────────────────────────│
│  • 테스트는 빨라야 함 (밀리초 단위)                           │
│  • 느린 테스트는 자주 실행하지 않게 됨                        │
│  • 외부 의존성 제거 (DB, 네트워크 등)                         │
│                                                                │
│  I - Independent (독립적)                                      │
│  ─────────────────────────────────────────────────────────────│
│  • 테스트는 서로 독립적이어야 함                              │
│  • 실행 순서에 영향받지 않아야 함                             │
│  • 한 테스트가 다른 테스트에 영향 주면 안 됨                  │
│                                                                │
│  R - Repeatable (반복 가능)                                    │
│  ─────────────────────────────────────────────────────────────│
│  • 어떤 환경에서든 같은 결과                                  │
│  • 언제 실행해도 같은 결과                                    │
│  • 외부 요인에 의존하지 않음                                  │
│                                                                │
│  S - Self-Validating (자가 검증)                               │
│  ─────────────────────────────────────────────────────────────│
│  • 성공/실패가 자동으로 판단됨                                │
│  • 수동 확인 불필요                                           │
│  • Assert로 명확한 검증                                       │
│                                                                │
│  T - Timely (적시)                                             │
│  ─────────────────────────────────────────────────────────────│
│  • 테스트는 프로덕션 코드 직전에 작성                         │
│  • 나중에 작성하면 테스트하기 어려운 코드가 됨                │
│  • TDD의 핵심!                                                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 8. 테스트 명명 규칙

### Step 8.1: 테스트 이름 짓기

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 명명 규칙                                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  패턴: [메서드명]_[시나리오]_[예상결과]                        │
│                                                                │
│  예시:                                                         │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ Add_TwoPositiveNumbers_ReturnsSum                        │ │
│  │ ─┬─ ────────┬───────── ─────┬─────                       │ │
│  │  │          │               │                            │ │
│  │  │          │               └─ 예상 결과                 │ │
│  │  │          │                  (합계를 반환)             │ │
│  │  │          │                                            │ │
│  │  │          └─ 시나리오/조건                            │ │
│  │  │             (두 양수)                                 │ │
│  │  │                                                       │ │
│  │  └─ 테스트할 메서드                                     │ │
│  │     (Add)                                                │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  더 많은 예시:                                                 │
│  • Divide_ByZero_ThrowsException                              │
│  • Login_ValidCredentials_ReturnsUser                         │
│  • GetUser_InvalidId_ReturnsNull                              │
│  • CreateOrder_EmptyCart_ThrowsException                      │
│  • SendEmail_InvalidAddress_ReturnsFalse                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 8.2: Given-When-Then 스타일

```
┌────────────────────────────────────────────────────────────────┐
│  Given-When-Then 스타일                                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  BDD(Behavior-Driven Development) 스타일의 명명법             │
│                                                                │
│  패턴: Given[조건]_When[동작]_Then[결과]                       │
│                                                                │
│  예시:                                                         │
│  • GivenEmptyCart_WhenAddItem_ThenCartHasOneItem              │
│  • GivenLoggedInUser_WhenLogout_ThenUserIsLoggedOut           │
│  • GivenInvalidEmail_WhenRegister_ThenThrowsError             │
│                                                                │
│  또는 Should 스타일:                                           │
│  • Add_ShouldReturnSum_WhenGivenTwoNumbers                    │
│  • Login_ShouldThrowException_WhenPasswordIsWrong             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 9. AAA 패턴 복습

### Step 9.1: Arrange-Act-Assert

```
┌────────────────────────────────────────────────────────────────┐
│  AAA 패턴                                                      │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  [Test]                                                        │
│  public void Add_TwoNumbers_ReturnsSum()                       │
│  {                                                             │
│      // ═══════════════════════════════════════════════════   │
│      // Arrange (준비)                                         │
│      // ═══════════════════════════════════════════════════   │
│      var calculator = new Calculator();                        │
│      int a = 5;                                                │
│      int b = 3;                                                │
│                                                                │
│      // ═══════════════════════════════════════════════════   │
│      // Act (실행)                                             │
│      // ═══════════════════════════════════════════════════   │
│      int result = calculator.Add(a, b);                        │
│                                                                │
│      // ═══════════════════════════════════════════════════   │
│      // Assert (검증)                                          │
│      // ═══════════════════════════════════════════════════   │
│      Assert.AreEqual(8, result);                               │
│  }                                                             │
│                                                                │
│  비율 권장: Arrange 60% / Act 10% / Assert 30%                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 10. 작은 단계로 진행하기

### Step 10.1: Baby Steps

```
┌────────────────────────────────────────────────────────────────┐
│  Baby Steps (아기 걸음)                                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  TDD의 핵심 원칙: 작은 단계로 진행                             │
│                                                                │
│  ❌ 나쁜 예: 한 번에 큰 기능 구현                              │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ 1. 전체 계산기 기능을 한 번에 테스트                     │ │
│  │ 2. 모든 연산을 한 번에 구현                              │ │
│  │ 3. 예외 처리도 한 번에 추가                              │ │
│  │                                                          │ │
│  │ → 디버깅 어려움, 어디서 문제인지 모름                    │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  ✅ 좋은 예: 작은 단계로 진행                                  │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ 1. Add(2, 3) = 5 테스트 & 구현                           │ │
│  │ 2. Add(0, 0) = 0 테스트 & 구현                           │ │
│  │ 3. Add(-1, 1) = 0 테스트 & 구현                          │ │
│  │ 4. Subtract 테스트 & 구현                                │ │
│  │ 5. Divide 테스트 & 구현                                  │ │
│  │ 6. Divide(x, 0) 예외 테스트 & 구현                       │ │
│  │                                                          │ │
│  │ → 각 단계에서 문제 발생 시 바로 확인 가능                │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 11. TODO 리스트 활용

### Step 11.1: TDD TODO 리스트

```
┌────────────────────────────────────────────────────────────────┐
│  TODO 리스트 활용                                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  TDD를 시작하기 전에 구현할 기능을 리스트로 작성              │
│                                                                │
│  예시: 계산기 TODO 리스트                                      │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │                                                          │ │
│  │  [ ] 두 양수 덧셈                                        │ │
│  │  [ ] 음수가 포함된 덧셈                                  │ │
│  │  [ ] 0이 포함된 덧셈                                     │ │
│  │  [ ] 뺄셈                                                │ │
│  │  [ ] 곱셈                                                │ │
│  │  [ ] 나눗셈                                              │ │
│  │  [ ] 0으로 나누기 예외                                   │ │
│  │                                                          │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  진행하면서:                                                   │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │                                                          │ │
│  │  [✅] 두 양수 덧셈                 ← 완료!               │ │
│  │  [✅] 음수가 포함된 덧셈           ← 완료!               │ │
│  │  [🔴] 0이 포함된 덧셈              ← 현재 진행 중        │ │
│  │  [ ] 뺄셈                                                │ │
│  │  [ ] 곱셈                                                │ │
│  │  [ ] 나눗셈                                              │ │
│  │  [ ] 0으로 나누기 예외                                   │ │
│  │  [ ] 큰 숫자 처리 (새로 추가됨)    ← 진행 중 발견        │ │
│  │                                                          │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 12. TDD 사이클 시각화

### Step 12.1: 전체 흐름 다이어그램

```
┌────────────────────────────────────────────────────────────────┐
│  TDD 전체 흐름                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                      시작                                │  │
│  │                        │                                 │  │
│  │                        ▼                                 │  │
│  │              ┌─────────────────┐                         │  │
│  │              │ TODO 리스트에서 │                         │  │
│  │              │ 하나 선택       │                         │  │
│  │              └────────┬────────┘                         │  │
│  │                       │                                  │  │
│  │                       ▼                                  │  │
│  │  ┌────────────────────────────────────────────────────┐ │  │
│  │  │                                                    │ │  │
│  │  │    🔴 실패하는 테스트 작성                        │ │  │
│  │  │              │                                     │ │  │
│  │  │              ▼                                     │ │  │
│  │  │         테스트 실행 → 실패 확인                   │ │  │
│  │  │              │                                     │ │  │
│  │  │              ▼                                     │ │  │
│  │  │    🟢 테스트 통과하는 코드 작성                   │ │  │
│  │  │              │                                     │ │  │
│  │  │              ▼                                     │ │  │
│  │  │         테스트 실행 → 통과 확인                   │ │  │
│  │  │              │                                     │ │  │
│  │  │              ▼                                     │ │  │
│  │  │    🔵 리팩토링                                    │ │  │
│  │  │              │                                     │ │  │
│  │  │              ▼                                     │ │  │
│  │  │         테스트 실행 → 여전히 통과 확인           │ │  │
│  │  │                                                    │ │  │
│  │  └────────────────────────────────────────────────────┘ │  │
│  │                       │                                  │  │
│  │                       ▼                                  │  │
│  │              ┌─────────────────┐                         │  │
│  │              │ TODO 완료?      │                         │  │
│  │              └────────┬────────┘                         │  │
│  │                  ┌────┴────┐                             │  │
│  │               아니오      예                             │  │
│  │                  │         │                             │  │
│  │                  ▼         ▼                             │  │
│  │            다음 TODO    종료                             │  │
│  │                                                          │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

# Part 2: 환경 설정

---

## 13. 솔루션 생성

### Step 13.1: Visual Studio에서 새 솔루션 생성

1. Visual Studio 실행
2. **파일** → **새로 만들기** → **프로젝트**
3. **빈 솔루션** 선택
4. 이름: `TDDCalculator`

---

## 14. 테스트 프로젝트 먼저 생성

### Step 14.1: TDD는 테스트 프로젝트부터!

```
┌────────────────────────────────────────────────────────────────┐
│  TDD에서는 테스트 프로젝트를 먼저 생성!                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  일반적인 개발:                                                │
│  1. 프로덕션 프로젝트 생성                                    │
│  2. 테스트 프로젝트 생성                                      │
│                                                                │
│  TDD:                                                          │
│  1. 테스트 프로젝트 생성  ← 먼저!                             │
│  2. 프로덕션 프로젝트 생성 (테스트 작성 중 필요할 때)         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 14.2: 테스트 프로젝트 추가

1. 솔루션 우클릭 → **추가** → **새 프로젝트**
2. **단위 테스트 프로젝트(.NET Framework)** 선택
3. 이름: `Calculator.Tests`

---

## 15. NuGet 패키지 설치

### Step 15.1: NUnit 패키지 설치

`Calculator.Tests` 프로젝트에 다음 패키지 설치:

| 패키지 | 설명 |
|--------|------|
| NUnit | 테스트 프레임워크 |
| NUnit3TestAdapter | VS 연동 |
| Microsoft.NET.Test.Sdk | 테스트 SDK |

---

## 16. 프로젝트 구조 확인

### Step 16.1: 현재 솔루션 구조

```
┌────────────────────────────────────────────────────────────────┐
│  솔루션 탐색기                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ▼ 솔루션 'TDDCalculator'                                      │
│    ▼ Calculator.Tests              ← 테스트 프로젝트만 있음!  │
│        ▶ 참조                                                  │
│        ▶ 패키지                                                │
│                                                                │
│  (프로덕션 프로젝트는 아직 없음)                               │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

# Part 3: 첫 번째 TDD 사이클 - 덧셈

---

## 17. TODO 리스트 작성

### Step 17.1: 계산기 TODO 리스트

```
┌────────────────────────────────────────────────────────────────┐
│  📝 계산기 TODO 리스트                                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  덧셈 (Add)                                                    │
│  [ ] 두 양수 덧셈: 2 + 3 = 5                                  │
│  [ ] 음수 덧셈: -2 + -3 = -5                                  │
│  [ ] 0과의 덧셈: 5 + 0 = 5                                    │
│                                                                │
│  뺄셈 (Subtract)                                               │
│  [ ] 두 양수 뺄셈: 5 - 3 = 2                                  │
│  [ ] 음수 결과: 3 - 5 = -2                                    │
│                                                                │
│  나눗셈 (Divide)                                               │
│  [ ] 정상 나눗셈: 10 / 2 = 5                                  │
│  [ ] 0으로 나누기: 예외 발생                                  │
│                                                                │
│  지금 할 것: 두 양수 덧셈 ◄───────────────────────────────────│
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 18. 🔴 RED: 첫 번째 실패하는 테스트

### Step 18.1: 테스트 파일 생성

1. `Calculator.Tests` 프로젝트에 새 클래스 추가
2. 이름: `CalculatorTests.cs`

### Step 18.2: 첫 번째 테스트 작성

```csharp
using NUnit.Framework;

namespace Calculator.Tests
{
    [TestFixture]
    public class CalculatorTests
    {
        [Test]
        public void Add_TwoPositiveNumbers_ReturnsSum()
        {
            // Arrange
            var calculator = new Calculator();
            
            // Act
            int result = calculator.Add(2, 3);
            
            // Assert
            Assert.AreEqual(5, result);
        }
    }
}
```

### Step 18.3: 컴파일 에러 확인

```
┌────────────────────────────────────────────────────────────────┐
│  🔴 RED 상태 - 컴파일 에러!                                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  오류 CS0246: 'Calculator' 형식 또는 네임스페이스 이름을       │
│  찾을 수 없습니다.                                             │
│                                                                │
│  → Calculator 클래스가 아직 없기 때문!                         │
│  → 이것이 정상입니다. TDD에서는 이렇게 시작합니다.            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 19. 프로덕션 프로젝트 생성

### Step 19.1: 이제 프로덕션 프로젝트가 필요!

테스트를 통과시키기 위해 프로덕션 프로젝트가 필요합니다.

1. 솔루션 우클릭 → **추가** → **새 프로젝트**
2. **클래스 라이브러리(.NET Framework)** 선택
3. 이름: `Calculator`

### Step 19.2: 참조 추가

1. `Calculator.Tests` → **참조** 우클릭
2. **참조 추가** → **Calculator** 체크

### Step 19.3: 솔루션 구조

```
┌────────────────────────────────────────────────────────────────┐
│  솔루션 탐색기                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ▼ 솔루션 'TDDCalculator'                                      │
│    ▼ Calculator                    ← 프로덕션 프로젝트 추가!  │
│        ▶ 참조                                                  │
│        Class1.cs (삭제 예정)                                   │
│    ▼ Calculator.Tests                                          │
│        ▶ 참조                                                  │
│          └── Calculator            ← 참조 추가됨              │
│        CalculatorTests.cs                                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 20. 🔴 RED: 여전히 실패하는 테스트

### Step 20.1: Calculator 클래스 생성 (최소한)

`Calculator` 프로젝트에 `Calculator.cs` 파일 생성:

```csharp
namespace Calculator
{
    public class Calculator
    {
        // 아직 메서드 없음!
    }
}
```

### Step 20.2: 테스트 파일에 using 추가

```csharp
using NUnit.Framework;
using Calculator;  // 추가!

namespace Calculator.Tests
{
    // ...
}
```

### Step 20.3: 컴파일 에러 확인

```
┌────────────────────────────────────────────────────────────────┐
│  🔴 RED 상태 - 여전히 컴파일 에러!                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  오류 CS1061: 'Calculator'에 'Add'에 대한 정의가 없습니다.     │
│                                                                │
│  → Add 메서드가 아직 없기 때문!                                │
│  → 계속 진행합니다.                                            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 21. 🟢 GREEN: 테스트 통과하는 코드

### Step 21.1: Add 메서드 추가 (최소한의 코드)

```csharp
namespace Calculator
{
    public class Calculator
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
    }
}
```

### Step 21.2: 테스트 실행

`Ctrl + R, A`로 테스트 실행:

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 탐색기                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ✅ 테스트 실행 완료: 1 통과, 0 실패                           │
│                                                                │
│  ▼ Calculator.Tests                                            │
│    ▼ CalculatorTests                                           │
│      ✅ Add_TwoPositiveNumbers_ReturnsSum                      │
│                                                                │
│  🟢 GREEN! 테스트 통과!                                        │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 22. 🔵 REFACTOR: 리팩토링

### Step 22.1: 리팩토링이 필요한가?

```
┌────────────────────────────────────────────────────────────────┐
│  🔵 REFACTOR 체크리스트                                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  현재 코드:                                                    │
│  public int Add(int a, int b)                                  │
│  {                                                             │
│      return a + b;                                             │
│  }                                                             │
│                                                                │
│  체크:                                                         │
│  ☑ 중복 코드 있는가? → 없음                                   │
│  ☑ 변수명 개선 필요? → 간단해서 괜찮음                        │
│  ☑ 메서드 분리 필요? → 아니오                                 │
│  ☑ 상수 추출 필요? → 아니오                                   │
│                                                                │
│  결론: 리팩토링 불필요! 다음 단계로 진행                       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 23. TODO 업데이트

### Step 23.1: 완료된 항목 체크

```
┌────────────────────────────────────────────────────────────────┐
│  📝 계산기 TODO 리스트 (업데이트)                              │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  덧셈 (Add)                                                    │
│  [✅] 두 양수 덧셈: 2 + 3 = 5        ← 완료!                  │
│  [ ] 음수 덧셈: -2 + -3 = -5                                  │
│  [ ] 0과의 덧셈: 5 + 0 = 5                                    │
│                                                                │
│  뺄셈 (Subtract)                                               │
│  [ ] 두 양수 뺄셈: 5 - 3 = 2                                  │
│  [ ] 음수 결과: 3 - 5 = -2                                    │
│                                                                │
│  나눗셈 (Divide)                                               │
│  [ ] 정상 나눗셈: 10 / 2 = 5                                  │
│  [ ] 0으로 나누기: 예외 발생                                  │
│                                                                │
│  다음 할 것: 음수 덧셈 ◄───────────────────────────────────────│
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 24. 🔴 RED: 음수 덧셈 테스트

### Step 24.1: 새 테스트 추가

```csharp
[Test]
public void Add_TwoNegativeNumbers_ReturnsSum()
{
    // Arrange
    var calculator = new Calculator();
    
    // Act
    int result = calculator.Add(-2, -3);
    
    // Assert
    Assert.AreEqual(-5, result);
}
```

### Step 24.2: 테스트 실행

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 탐색기                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ✅ 테스트 실행 완료: 2 통과, 0 실패                           │
│                                                                │
│  ▼ Calculator.Tests                                            │
│    ▼ CalculatorTests                                           │
│      ✅ Add_TwoPositiveNumbers_ReturnsSum                      │
│      ✅ Add_TwoNegativeNumbers_ReturnsSum   ← 바로 통과!       │
│                                                                │
│  이미 구현된 코드가 새 테스트도 통과함!                        │
│  → 이것도 TDD의 일부입니다.                                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 25. 0과의 덧셈 테스트

### Step 25.1: 새 테스트 추가

```csharp
[Test]
public void Add_NumberAndZero_ReturnsSameNumber()
{
    // Arrange
    var calculator = new Calculator();
    
    // Act
    int result = calculator.Add(5, 0);
    
    // Assert
    Assert.AreEqual(5, result);
}
```

### Step 25.2: 테스트 실행

```
✅ 3 통과, 0 실패
```

---

## 26. 덧셈 테스트 리팩토링

### Step 26.1: 테스트 코드 리팩토링

테스트 코드도 리팩토링 대상입니다!

**Before (중복 많음):**
```csharp
[Test]
public void Add_TwoPositiveNumbers_ReturnsSum()
{
    var calculator = new Calculator();  // 중복!
    int result = calculator.Add(2, 3);
    Assert.AreEqual(5, result);
}

[Test]
public void Add_TwoNegativeNumbers_ReturnsSum()
{
    var calculator = new Calculator();  // 중복!
    int result = calculator.Add(-2, -3);
    Assert.AreEqual(-5, result);
}
```

**After (SetUp 사용):**
```csharp
[TestFixture]
public class CalculatorTests
{
    private Calculator _calculator;
    
    [SetUp]
    public void SetUp()
    {
        _calculator = new Calculator();
    }
    
    [Test]
    public void Add_TwoPositiveNumbers_ReturnsSum()
    {
        int result = _calculator.Add(2, 3);
        Assert.AreEqual(5, result);
    }
    
    [Test]
    public void Add_TwoNegativeNumbers_ReturnsSum()
    {
        int result = _calculator.Add(-2, -3);
        Assert.AreEqual(-5, result);
    }
}
```

### Step 26.2: TestCase로 더 간결하게

```csharp
[TestCase(2, 3, 5, Description = "양수 + 양수")]
[TestCase(-2, -3, -5, Description = "음수 + 음수")]
[TestCase(5, 0, 5, Description = "숫자 + 0")]
[TestCase(0, 5, 5, Description = "0 + 숫자")]
[TestCase(-5, 5, 0, Description = "음수 + 양수 = 0")]
public void Add_VariousInputs_ReturnsExpectedSum(int a, int b, int expected)
{
    int result = _calculator.Add(a, b);
    Assert.AreEqual(expected, result);
}
```

### Step 26.3: 리팩토링 후 테스트 실행

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 탐색기                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ✅ 테스트 실행 완료: 5 통과, 0 실패                           │
│                                                                │
│  ▼ Add_VariousInputs_ReturnsExpectedSum (5)                    │
│    ✅ Add_VariousInputs_ReturnsExpectedSum(2, 3, 5)            │
│    ✅ Add_VariousInputs_ReturnsExpectedSum(-2, -3, -5)         │
│    ✅ Add_VariousInputs_ReturnsExpectedSum(5, 0, 5)            │
│    ✅ Add_VariousInputs_ReturnsExpectedSum(0, 5, 5)            │
│    ✅ Add_VariousInputs_ReturnsExpectedSum(-5, 5, 0)           │
│                                                                │
│  🔵 리팩토링 완료! 모든 테스트 여전히 통과!                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

이어서 Part 2를 작성하겠습니다.
# 🔴🟢🔵 TDD 따라하기 실습 (상세 버전) - Part 2

---

# Part 4: 두 번째 TDD 사이클 - 뺄셈

---

## 27. TODO 업데이트

### Step 27.1: 현재 TODO 상태

```
┌────────────────────────────────────────────────────────────────┐
│  📝 계산기 TODO 리스트                                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  덧셈 (Add)                                                    │
│  [✅] 두 양수 덧셈                                             │
│  [✅] 음수 덧셈                                                │
│  [✅] 0과의 덧셈                                               │
│                                                                │
│  뺄셈 (Subtract)                                               │
│  [🔴] 두 양수 뺄셈: 5 - 3 = 2        ← 현재 진행!             │
│  [ ] 음수 결과: 3 - 5 = -2                                    │
│                                                                │
│  나눗셈 (Divide)                                               │
│  [ ] 정상 나눗셈: 10 / 2 = 5                                  │
│  [ ] 0으로 나누기: 예외 발생                                  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 28. 🔴 RED: 뺄셈 테스트 작성

### Step 28.1: 첫 번째 뺄셈 테스트

```csharp
[Test]
public void Subtract_TwoPositiveNumbers_ReturnsDifference()
{
    // Arrange - SetUp에서 _calculator 생성됨
    
    // Act
    int result = _calculator.Subtract(5, 3);
    
    // Assert
    Assert.AreEqual(2, result);
}
```

### Step 28.2: 컴파일 에러 확인

```
┌────────────────────────────────────────────────────────────────┐
│  🔴 RED 상태 - 컴파일 에러!                                    │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  오류 CS1061: 'Calculator'에 'Subtract'에 대한 정의가          │
│  없습니다.                                                     │
│                                                                │
│  → Subtract 메서드가 아직 없음!                                │
│  → 정상적인 RED 상태입니다.                                    │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 29. 🟢 GREEN: Subtract 메서드 구현

### Step 29.1: 최소한의 코드 작성

```csharp
namespace Calculator
{
    public class Calculator
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
        
        public int Subtract(int a, int b)
        {
            return a - b;
        }
    }
}
```

### Step 29.2: 테스트 실행

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 탐색기                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ✅ 테스트 실행 완료: 6 통과, 0 실패                           │
│                                                                │
│  ▼ Calculator.Tests                                            │
│    ✅ Add_VariousInputs_ReturnsExpectedSum (5개)               │
│    ✅ Subtract_TwoPositiveNumbers_ReturnsDifference            │
│                                                                │
│  🟢 GREEN! 새 테스트도 통과!                                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 30. 추가 뺄셈 테스트

### Step 30.1: 음수 결과 테스트

```csharp
[Test]
public void Subtract_SmallerFromLarger_ReturnsNegative()
{
    int result = _calculator.Subtract(3, 5);
    Assert.AreEqual(-2, result);
}
```

### Step 30.2: 테스트 실행 - 바로 통과!

```
✅ 7 통과, 0 실패
```

---

## 31. 뺄셈 테스트 리팩토링

### Step 31.1: TestCase로 통합

```csharp
[TestCase(5, 3, 2, Description = "큰 수 - 작은 수")]
[TestCase(3, 5, -2, Description = "작은 수 - 큰 수")]
[TestCase(5, 5, 0, Description = "같은 수")]
[TestCase(-3, -5, 2, Description = "음수 - 음수")]
[TestCase(5, 0, 5, Description = "숫자 - 0")]
public void Subtract_VariousInputs_ReturnsExpectedDifference(int a, int b, int expected)
{
    int result = _calculator.Subtract(a, b);
    Assert.AreEqual(expected, result);
}
```

---

## 32. 🔵 REFACTOR: 프로덕션 코드 점검

### Step 32.1: 현재 Calculator 클래스

```csharp
namespace Calculator
{
    public class Calculator
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
        
        public int Subtract(int a, int b)
        {
            return a - b;
        }
    }
}
```

### Step 32.2: 리팩토링 체크

```
┌────────────────────────────────────────────────────────────────┐
│  🔵 REFACTOR 체크리스트                                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ☑ 중복 코드? → 없음                                          │
│  ☑ 네이밍? → 명확함                                           │
│  ☑ 메서드 길이? → 적절함 (1줄)                                │
│                                                                │
│  결론: 현재 상태로 충분함!                                     │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 33. TODO 업데이트

```
┌────────────────────────────────────────────────────────────────┐
│  📝 계산기 TODO 리스트                                         │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  덧셈 (Add)                                                    │
│  [✅] 두 양수 덧셈                                             │
│  [✅] 음수 덧셈                                                │
│  [✅] 0과의 덧셈                                               │
│                                                                │
│  뺄셈 (Subtract)                                               │
│  [✅] 두 양수 뺄셈                                             │
│  [✅] 음수 결과                                                │
│                                                                │
│  나눗셈 (Divide)                                               │
│  [🔴] 정상 나눗셈: 10 / 2 = 5        ← 다음!                  │
│  [ ] 0으로 나누기: 예외 발생                                  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

# Part 5: 세 번째 TDD 사이클 - 나눗셈과 예외

---

## 34. 🔴 RED: 나눗셈 테스트 작성

### Step 34.1: 정상 나눗셈 테스트

```csharp
[Test]
public void Divide_TwoNumbers_ReturnsQuotient()
{
    int result = _calculator.Divide(10, 2);
    Assert.AreEqual(5, result);
}
```

### Step 34.2: 컴파일 에러

```
오류 CS1061: 'Calculator'에 'Divide'에 대한 정의가 없습니다.
```

---

## 35. 🟢 GREEN: Divide 메서드 구현

### Step 35.1: 최소한의 코드

```csharp
public int Divide(int dividend, int divisor)
{
    return dividend / divisor;
}
```

### Step 35.2: 테스트 통과

```
✅ 모든 테스트 통과!
```

---

## 36. 🔴 RED: 0으로 나누기 예외 테스트

### Step 36.1: 예외 테스트 작성

```csharp
[Test]
public void Divide_ByZero_ThrowsDivideByZeroException()
{
    Assert.Throws<DivideByZeroException>(() => 
        _calculator.Divide(10, 0));
}
```

### Step 36.2: 테스트 실행

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 탐색기                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ✅ 테스트 실행 완료: 모든 테스트 통과                         │
│                                                                │
│  Divide_ByZero_ThrowsDivideByZeroException ✅                  │
│                                                                │
│  왜 바로 통과했나?                                             │
│  → C#에서 정수를 0으로 나누면 자동으로                        │
│    DivideByZeroException이 발생하기 때문!                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 37. 예외 메시지 검증

### Step 37.1: 커스텀 예외 메시지 테스트

좀 더 친절한 에러 메시지를 원한다면:

```csharp
[Test]
public void Divide_ByZero_ThrowsExceptionWithMessage()
{
    var exception = Assert.Throws<DivideByZeroException>(() => 
        _calculator.Divide(10, 0));
    
    Assert.That(exception.Message, Does.Contain("0으로 나눌 수 없습니다"));
}
```

### Step 37.2: 테스트 실행 - 실패!

```
┌────────────────────────────────────────────────────────────────┐
│  🔴 RED 상태!                                                  │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ❌ Divide_ByZero_ThrowsExceptionWithMessage                   │
│                                                                │
│  Expected: String containing "0으로 나눌 수 없습니다"          │
│  But was:  "Attempted to divide by zero."                      │
│                                                                │
│  → 기본 예외 메시지는 영어임!                                  │
│  → 커스텀 메시지를 위해 코드 수정 필요                         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 38. 🟢 GREEN: 커스텀 예외 메시지

### Step 38.1: Divide 메서드 수정

```csharp
public int Divide(int dividend, int divisor)
{
    if (divisor == 0)
    {
        throw new DivideByZeroException("0으로 나눌 수 없습니다.");
    }
    
    return dividend / divisor;
}
```

### Step 38.2: 테스트 통과

```
✅ 모든 테스트 통과!
```

---

## 39. 나눗셈 테스트 확장

### Step 39.1: 다양한 케이스 추가

```csharp
[TestCase(10, 2, 5)]
[TestCase(9, 3, 3)]
[TestCase(-10, 2, -5)]
[TestCase(10, -2, -5)]
[TestCase(-10, -2, 5)]
[TestCase(0, 5, 0)]
[TestCase(7, 2, 3, Description = "정수 나눗셈 (나머지 버림)")]
public void Divide_VariousInputs_ReturnsExpectedQuotient(int dividend, int divisor, int expected)
{
    int result = _calculator.Divide(dividend, divisor);
    Assert.AreEqual(expected, result);
}
```

---

## 40. 🔵 REFACTOR: 전체 코드 리팩토링

### Step 40.1: 현재 Calculator 클래스

```csharp
using System;

namespace Calculator
{
    public class Calculator
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
        
        public int Subtract(int a, int b)
        {
            return a - b;
        }
        
        public int Divide(int dividend, int divisor)
        {
            if (divisor == 0)
            {
                throw new DivideByZeroException("0으로 나눌 수 없습니다.");
            }
            
            return dividend / divisor;
        }
    }
}
```

### Step 40.2: XML 문서 추가 (선택)

```csharp
using System;

namespace Calculator
{
    /// <summary>
    /// 기본 사칙연산을 수행하는 계산기 클래스
    /// </summary>
    public class Calculator
    {
        /// <summary>
        /// 두 정수를 더합니다.
        /// </summary>
        public int Add(int a, int b)
        {
            return a + b;
        }
        
        /// <summary>
        /// 두 정수를 뺍니다.
        /// </summary>
        public int Subtract(int a, int b)
        {
            return a - b;
        }
        
        /// <summary>
        /// 두 정수를 나눕니다.
        /// </summary>
        /// <exception cref="DivideByZeroException">divisor가 0일 때</exception>
        public int Divide(int dividend, int divisor)
        {
            if (divisor == 0)
            {
                throw new DivideByZeroException("0으로 나눌 수 없습니다.");
            }
            
            return dividend / divisor;
        }
    }
}
```

---

## 41. 현재 테스트 전체 코드

### Step 41.1: CalculatorTests.cs

```csharp
using System;
using NUnit.Framework;

namespace Calculator.Tests
{
    [TestFixture]
    public class CalculatorTests
    {
        private Calculator _calculator;
        
        [SetUp]
        public void SetUp()
        {
            _calculator = new Calculator();
        }
        
        #region Add Tests
        
        [TestCase(2, 3, 5, Description = "양수 + 양수")]
        [TestCase(-2, -3, -5, Description = "음수 + 음수")]
        [TestCase(5, 0, 5, Description = "숫자 + 0")]
        [TestCase(0, 5, 5, Description = "0 + 숫자")]
        [TestCase(-5, 5, 0, Description = "음수 + 양수 = 0")]
        public void Add_VariousInputs_ReturnsExpectedSum(int a, int b, int expected)
        {
            int result = _calculator.Add(a, b);
            Assert.AreEqual(expected, result);
        }
        
        #endregion
        
        #region Subtract Tests
        
        [TestCase(5, 3, 2, Description = "큰 수 - 작은 수")]
        [TestCase(3, 5, -2, Description = "작은 수 - 큰 수")]
        [TestCase(5, 5, 0, Description = "같은 수")]
        [TestCase(-3, -5, 2, Description = "음수 - 음수")]
        [TestCase(5, 0, 5, Description = "숫자 - 0")]
        public void Subtract_VariousInputs_ReturnsExpectedDifference(int a, int b, int expected)
        {
            int result = _calculator.Subtract(a, b);
            Assert.AreEqual(expected, result);
        }
        
        #endregion
        
        #region Divide Tests
        
        [TestCase(10, 2, 5)]
        [TestCase(9, 3, 3)]
        [TestCase(-10, 2, -5)]
        [TestCase(10, -2, -5)]
        [TestCase(-10, -2, 5)]
        [TestCase(0, 5, 0)]
        [TestCase(7, 2, 3, Description = "정수 나눗셈")]
        public void Divide_VariousInputs_ReturnsExpectedQuotient(int dividend, int divisor, int expected)
        {
            int result = _calculator.Divide(dividend, divisor);
            Assert.AreEqual(expected, result);
        }
        
        [Test]
        public void Divide_ByZero_ThrowsDivideByZeroException()
        {
            Assert.Throws<DivideByZeroException>(() => 
                _calculator.Divide(10, 0));
        }
        
        [Test]
        public void Divide_ByZero_ThrowsExceptionWithMessage()
        {
            var exception = Assert.Throws<DivideByZeroException>(() => 
                _calculator.Divide(10, 0));
            
            Assert.That(exception.Message, Does.Contain("0으로 나눌 수 없습니다"));
        }
        
        #endregion
    }
}
```

---

## 42. TODO 완료 확인

```
┌────────────────────────────────────────────────────────────────┐
│  📝 계산기 TODO 리스트 (완료!)                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  덧셈 (Add)                                                    │
│  [✅] 두 양수 덧셈                                             │
│  [✅] 음수 덧셈                                                │
│  [✅] 0과의 덧셈                                               │
│                                                                │
│  뺄셈 (Subtract)                                               │
│  [✅] 두 양수 뺄셈                                             │
│  [✅] 음수 결과                                                │
│                                                                │
│  나눗셈 (Divide)                                               │
│  [✅] 정상 나눗셈                                              │
│  [✅] 0으로 나누기 예외                                        │
│                                                                │
│  🎉 기본 계산기 TDD 완료!                                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

# Part 6: 실전 TDD - 문자열 계산기

---

## 43. 문자열 계산기 요구사항

### Step 43.1: 요구사항 정의

```
┌────────────────────────────────────────────────────────────────┐
│  문자열 계산기 요구사항                                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  쉼표(,) 또는 콜론(:)으로 구분된 숫자 문자열을 받아            │
│  각 숫자의 합을 반환하는 계산기                                │
│                                                                │
│  예시:                                                         │
│  • "" → 0                                                     │
│  • "1" → 1                                                    │
│  • "1,2" → 3                                                  │
│  • "1,2,3" → 6                                                │
│  • "1:2:3" → 6                                                │
│  • "1,2:3" → 6 (혼합 사용)                                    │
│  • 음수가 있으면 예외 발생                                     │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 43.2: TODO 리스트 작성

```
┌────────────────────────────────────────────────────────────────┐
│  📝 문자열 계산기 TODO 리스트                                  │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  [ ] 빈 문자열 → 0                                            │
│  [ ] 숫자 하나 → 해당 숫자                                    │
│  [ ] 쉼표로 구분된 두 숫자 → 합                               │
│  [ ] 쉼표로 구분된 여러 숫자 → 합                             │
│  [ ] 콜론으로 구분된 숫자 → 합                                │
│  [ ] 쉼표와 콜론 혼합 → 합                                    │
│  [ ] 음수 → 예외 발생                                         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 44. 🔴 RED: 빈 문자열 테스트

### Step 44.1: 테스트 클래스 생성

```csharp
using NUnit.Framework;

namespace Calculator.Tests
{
    [TestFixture]
    public class StringCalculatorTests
    {
        private StringCalculator _calculator;
        
        [SetUp]
        public void SetUp()
        {
            _calculator = new StringCalculator();
        }
        
        [Test]
        public void Add_EmptyString_ReturnsZero()
        {
            int result = _calculator.Add("");
            Assert.AreEqual(0, result);
        }
    }
}
```

### Step 44.2: 컴파일 에러

```
🔴 RED: StringCalculator 클래스가 없음!
```

---

## 45. 🟢 GREEN: StringCalculator 클래스 생성

### Step 45.1: 최소한의 코드

```csharp
namespace Calculator
{
    public class StringCalculator
    {
        public int Add(string numbers)
        {
            return 0;  // 빈 문자열에 대해 0 반환 - 하드코딩!
        }
    }
}
```

### Step 45.2: 테스트 통과

```
✅ 테스트 통과!
```

---

## 46. 🔴 RED: 숫자 하나 테스트

### Step 46.1: 새 테스트 추가

```csharp
[Test]
public void Add_SingleNumber_ReturnsThatNumber()
{
    int result = _calculator.Add("1");
    Assert.AreEqual(1, result);
}
```

### Step 46.2: 테스트 실패

```
🔴 RED: Expected 1, But was 0
```

---

## 47. 🟢 GREEN: 숫자 하나 처리

### Step 47.1: 코드 수정

```csharp
public int Add(string numbers)
{
    if (string.IsNullOrEmpty(numbers))
        return 0;
    
    return int.Parse(numbers);
}
```

### Step 47.2: 테스트 통과

```
✅ 2개 테스트 모두 통과!
```

---

## 48. 🔴 RED: 쉼표로 구분된 두 숫자

### Step 48.1: 새 테스트

```csharp
[Test]
public void Add_TwoNumbersWithComma_ReturnsSum()
{
    int result = _calculator.Add("1,2");
    Assert.AreEqual(3, result);
}
```

### Step 48.2: 테스트 실패

```
🔴 RED: FormatException - "1,2"는 정수로 파싱 불가!
```

---

## 49. 🟢 GREEN: 쉼표 구분 처리

### Step 49.1: 코드 수정

```csharp
public int Add(string numbers)
{
    if (string.IsNullOrEmpty(numbers))
        return 0;
    
    if (numbers.Contains(","))
    {
        var parts = numbers.Split(',');
        return int.Parse(parts[0]) + int.Parse(parts[1]);
    }
    
    return int.Parse(numbers);
}
```

### Step 49.2: 테스트 통과

```
✅ 3개 테스트 모두 통과!
```

---

## 50. 🔴 RED: 여러 숫자

### Step 50.1: 새 테스트

```csharp
[Test]
public void Add_MultipleNumbers_ReturnsSum()
{
    int result = _calculator.Add("1,2,3,4,5");
    Assert.AreEqual(15, result);
}
```

### Step 50.2: 테스트 실패

```
🔴 RED: Expected 15, But was 3 (처음 두 개만 더함)
```

---

## 51. 🟢 GREEN: 여러 숫자 처리

### Step 51.1: 코드 수정

```csharp
using System.Linq;

public int Add(string numbers)
{
    if (string.IsNullOrEmpty(numbers))
        return 0;
    
    if (numbers.Contains(","))
    {
        return numbers.Split(',')
                      .Select(int.Parse)
                      .Sum();
    }
    
    return int.Parse(numbers);
}
```

### Step 51.2: 테스트 통과

```
✅ 4개 테스트 모두 통과!
```

---

## 52. 🔴🟢 콜론 구분 추가

### Step 52.1: 테스트 추가

```csharp
[Test]
public void Add_NumbersWithColon_ReturnsSum()
{
    int result = _calculator.Add("1:2:3");
    Assert.AreEqual(6, result);
}
```

### Step 52.2: 코드 수정

```csharp
public int Add(string numbers)
{
    if (string.IsNullOrEmpty(numbers))
        return 0;
    
    var delimiters = new[] { ',', ':' };
    
    if (numbers.IndexOfAny(delimiters) >= 0)
    {
        return numbers.Split(delimiters)
                      .Select(int.Parse)
                      .Sum();
    }
    
    return int.Parse(numbers);
}
```

---

## 53. 🔵 REFACTOR: 코드 정리

### Step 53.1: 리팩토링된 코드

```csharp
using System;
using System.Linq;

namespace Calculator
{
    public class StringCalculator
    {
        private static readonly char[] DefaultDelimiters = { ',', ':' };
        
        public int Add(string numbers)
        {
            if (string.IsNullOrEmpty(numbers))
                return 0;
            
            var numberList = ParseNumbers(numbers);
            ValidateNoNegatives(numberList);
            
            return numberList.Sum();
        }
        
        private int[] ParseNumbers(string numbers)
        {
            return numbers.Split(DefaultDelimiters)
                          .Select(int.Parse)
                          .ToArray();
        }
        
        private void ValidateNoNegatives(int[] numbers)
        {
            var negatives = numbers.Where(n => n < 0).ToArray();
            
            if (negatives.Any())
            {
                throw new ArgumentException(
                    $"음수는 허용되지 않습니다: {string.Join(", ", negatives)}");
            }
        }
    }
}
```

---

## 54. 🔴🟢 음수 예외 테스트

### Step 54.1: 음수 테스트

```csharp
[Test]
public void Add_NegativeNumber_ThrowsException()
{
    var exception = Assert.Throws<ArgumentException>(() => 
        _calculator.Add("1,-2,3"));
    
    Assert.That(exception.Message, Does.Contain("-2"));
}

[Test]
public void Add_MultipleNegatives_ThrowsExceptionWithAllNegatives()
{
    var exception = Assert.Throws<ArgumentException>(() => 
        _calculator.Add("1,-2,-3,4"));
    
    Assert.That(exception.Message, Does.Contain("-2"));
    Assert.That(exception.Message, Does.Contain("-3"));
}
```

---

## 55. 문자열 계산기 최종 테스트

### Step 55.1: 전체 테스트 코드

```csharp
using System;
using NUnit.Framework;

namespace Calculator.Tests
{
    [TestFixture]
    public class StringCalculatorTests
    {
        private StringCalculator _calculator;
        
        [SetUp]
        public void SetUp()
        {
            _calculator = new StringCalculator();
        }
        
        [Test]
        public void Add_EmptyString_ReturnsZero()
        {
            Assert.AreEqual(0, _calculator.Add(""));
        }
        
        [Test]
        public void Add_Null_ReturnsZero()
        {
            Assert.AreEqual(0, _calculator.Add(null));
        }
        
        [TestCase("1", 1)]
        [TestCase("5", 5)]
        [TestCase("123", 123)]
        public void Add_SingleNumber_ReturnsThatNumber(string input, int expected)
        {
            Assert.AreEqual(expected, _calculator.Add(input));
        }
        
        [TestCase("1,2", 3)]
        [TestCase("1,2,3", 6)]
        [TestCase("1,2,3,4,5", 15)]
        public void Add_CommaSeparated_ReturnsSum(string input, int expected)
        {
            Assert.AreEqual(expected, _calculator.Add(input));
        }
        
        [TestCase("1:2", 3)]
        [TestCase("1:2:3", 6)]
        public void Add_ColonSeparated_ReturnsSum(string input, int expected)
        {
            Assert.AreEqual(expected, _calculator.Add(input));
        }
        
        [TestCase("1,2:3", 6)]
        [TestCase("1:2,3:4,5", 15)]
        public void Add_MixedDelimiters_ReturnsSum(string input, int expected)
        {
            Assert.AreEqual(expected, _calculator.Add(input));
        }
        
        [Test]
        public void Add_NegativeNumber_ThrowsArgumentException()
        {
            var ex = Assert.Throws<ArgumentException>(() => 
                _calculator.Add("1,-2,3"));
            
            Assert.That(ex.Message, Does.Contain("음수"));
            Assert.That(ex.Message, Does.Contain("-2"));
        }
    }
}
```

---

이어서 Part 3를 작성하겠습니다.
# 🔴🟢🔵 TDD 따라하기 실습 (상세 버전) - Part 3

---

# Part 7: 실전 TDD - 로그인 서비스

---

## 56. 로그인 서비스 요구사항

### Step 56.1: 요구사항 정의

```
┌────────────────────────────────────────────────────────────────┐
│  로그인 서비스 요구사항                                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 이메일과 비밀번호로 로그인                                 │
│  2. 성공 시 사용자 정보 반환                                   │
│  3. 실패 시 null 반환                                          │
│  4. 이메일 형식 검증                                           │
│  5. 비밀번호 최소 길이 검증                                    │
│  6. 로그인 시도 로깅                                           │
│  7. 실패 시 실패 횟수 기록                                     │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 56.2: TODO 리스트

```
┌────────────────────────────────────────────────────────────────┐
│  📝 로그인 서비스 TODO 리스트                                  │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  [ ] 유효한 자격 증명 → 사용자 반환                           │
│  [ ] 잘못된 이메일 → null 반환                                │
│  [ ] 잘못된 비밀번호 → null 반환                              │
│  [ ] 빈 이메일 → 예외                                         │
│  [ ] 빈 비밀번호 → 예외                                       │
│  [ ] 잘못된 이메일 형식 → 예외                                │
│  [ ] 짧은 비밀번호 → 예외                                     │
│  [ ] 로그인 성공 → 로그 기록                                  │
│  [ ] 로그인 실패 → 실패 횟수 증가                             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 57. 인터페이스 설계

### Step 57.1: 필요한 인터페이스 파악

```
┌────────────────────────────────────────────────────────────────┐
│  의존성 분석                                                   │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  LoginService가 필요로 하는 것:                                │
│                                                                │
│  1. IUserRepository                                            │
│     • 사용자 조회 (이메일로)                                  │
│     • 비밀번호 검증                                           │
│                                                                │
│  2. ILogger                                                    │
│     • 로그인 시도 기록                                        │
│     • 성공/실패 기록                                          │
│                                                                │
│  3. ILoginAttemptTracker                                       │
│     • 실패 횟수 기록                                          │
│     • 계정 잠금 확인                                          │
│                                                                │
│  ┌─────────────────┐                                           │
│  │  LoginService   │                                           │
│  └───────┬─────────┘                                           │
│          │                                                     │
│    ┌─────┼─────────┬─────────────────┐                         │
│    │     │         │                 │                         │
│    ▼     ▼         ▼                 ▼                         │
│  IUser  ILogger  ILoginAttempt    (Mock!)                      │
│  Repo            Tracker                                       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 58. 🔴 RED: 첫 번째 테스트 - 성공 로그인

### Step 58.1: 테스트 클래스 생성

```csharp
using Moq;
using NUnit.Framework;

namespace LoginSystem.Tests
{
    [TestFixture]
    public class LoginServiceTests
    {
        private Mock<IUserRepository> _mockUserRepo;
        private Mock<ILogger> _mockLogger;
        private LoginService _loginService;
        
        [SetUp]
        public void SetUp()
        {
            _mockUserRepo = new Mock<IUserRepository>();
            _mockLogger = new Mock<ILogger>();
            
            _loginService = new LoginService(
                _mockUserRepo.Object,
                _mockLogger.Object);
        }
        
        [Test]
        public void Login_ValidCredentials_ReturnsUser()
        {
            // Arrange
            var expectedUser = new User 
            { 
                Id = 1, 
                Email = "test@test.com", 
                Name = "테스트 사용자" 
            };
            
            _mockUserRepo
                .Setup(x => x.GetByEmail("test@test.com"))
                .Returns(expectedUser);
            
            _mockUserRepo
                .Setup(x => x.ValidatePassword(expectedUser, "password123"))
                .Returns(true);
            
            // Act
            var result = _loginService.Login("test@test.com", "password123");
            
            // Assert
            Assert.IsNotNull(result);
            Assert.AreEqual("test@test.com", result.Email);
        }
    }
}
```

### Step 58.2: 컴파일 에러들

```
🔴 RED: 많은 컴파일 에러!
- IUserRepository 없음
- ILogger 없음
- LoginService 없음
- User 없음
```

---

## 59. 🟢 GREEN: 인터페이스와 클래스 생성

### Step 59.1: User 클래스

```csharp
namespace LoginSystem
{
    public class User
    {
        public int Id { get; set; }
        public string Email { get; set; }
        public string Name { get; set; }
        public string PasswordHash { get; set; }
    }
}
```

### Step 59.2: IUserRepository 인터페이스

```csharp
namespace LoginSystem
{
    public interface IUserRepository
    {
        User GetByEmail(string email);
        bool ValidatePassword(User user, string password);
    }
}
```

### Step 59.3: ILogger 인터페이스

```csharp
namespace LoginSystem
{
    public interface ILogger
    {
        void LogInfo(string message);
        void LogWarning(string message);
        void LogError(string message);
    }
}
```

### Step 59.4: LoginService 클래스 (최소 구현)

```csharp
namespace LoginSystem
{
    public class LoginService
    {
        private readonly IUserRepository _userRepository;
        private readonly ILogger _logger;
        
        public LoginService(IUserRepository userRepository, ILogger logger)
        {
            _userRepository = userRepository;
            _logger = logger;
        }
        
        public User Login(string email, string password)
        {
            var user = _userRepository.GetByEmail(email);
            
            if (user != null && _userRepository.ValidatePassword(user, password))
            {
                return user;
            }
            
            return null;
        }
    }
}
```

### Step 59.5: 테스트 통과

```
✅ Login_ValidCredentials_ReturnsUser 통과!
```

---

## 60. 🔴🟢 잘못된 이메일 테스트

### Step 60.1: 테스트 추가

```csharp
[Test]
public void Login_InvalidEmail_ReturnsNull()
{
    // Arrange
    _mockUserRepo
        .Setup(x => x.GetByEmail("wrong@test.com"))
        .Returns((User)null);
    
    // Act
    var result = _loginService.Login("wrong@test.com", "password123");
    
    // Assert
    Assert.IsNull(result);
}
```

### Step 60.2: 테스트 통과

```
✅ 이미 구현된 코드가 이 케이스도 처리함!
```

---

## 61. 🔴🟢 잘못된 비밀번호 테스트

### Step 61.1: 테스트 추가

```csharp
[Test]
public void Login_WrongPassword_ReturnsNull()
{
    // Arrange
    var user = new User { Id = 1, Email = "test@test.com" };
    
    _mockUserRepo
        .Setup(x => x.GetByEmail("test@test.com"))
        .Returns(user);
    
    _mockUserRepo
        .Setup(x => x.ValidatePassword(user, "wrongpassword"))
        .Returns(false);
    
    // Act
    var result = _loginService.Login("test@test.com", "wrongpassword");
    
    // Assert
    Assert.IsNull(result);
}
```

---

## 62. 🔴 RED: 빈 이메일 검증

### Step 62.1: 테스트 추가

```csharp
[Test]
public void Login_EmptyEmail_ThrowsArgumentException()
{
    Assert.Throws<ArgumentException>(() => 
        _loginService.Login("", "password123"));
}

[Test]
public void Login_NullEmail_ThrowsArgumentException()
{
    Assert.Throws<ArgumentException>(() => 
        _loginService.Login(null, "password123"));
}
```

### Step 62.2: 테스트 실패

```
🔴 RED: 예외가 발생하지 않음!
```

---

## 63. 🟢 GREEN: 입력 검증 추가

### Step 63.1: LoginService 수정

```csharp
using System;

public User Login(string email, string password)
{
    // 입력 검증
    if (string.IsNullOrWhiteSpace(email))
        throw new ArgumentException("이메일은 필수입니다.", nameof(email));
    
    if (string.IsNullOrWhiteSpace(password))
        throw new ArgumentException("비밀번호는 필수입니다.", nameof(password));
    
    var user = _userRepository.GetByEmail(email);
    
    if (user != null && _userRepository.ValidatePassword(user, password))
    {
        return user;
    }
    
    return null;
}
```

---

## 64. 🔴🟢 이메일 형식 검증

### Step 64.1: 테스트 추가

```csharp
[TestCase("notanemail")]
[TestCase("missing@domain")]
[TestCase("@nodomain.com")]
public void Login_InvalidEmailFormat_ThrowsArgumentException(string invalidEmail)
{
    var ex = Assert.Throws<ArgumentException>(() => 
        _loginService.Login(invalidEmail, "password123"));
    
    Assert.That(ex.Message, Does.Contain("이메일 형식"));
}
```

### Step 64.2: 코드 수정

```csharp
using System.Text.RegularExpressions;

public User Login(string email, string password)
{
    // 입력 검증
    if (string.IsNullOrWhiteSpace(email))
        throw new ArgumentException("이메일은 필수입니다.", nameof(email));
    
    if (string.IsNullOrWhiteSpace(password))
        throw new ArgumentException("비밀번호는 필수입니다.", nameof(password));
    
    // 이메일 형식 검증
    if (!IsValidEmail(email))
        throw new ArgumentException("올바른 이메일 형식이 아닙니다.", nameof(email));
    
    var user = _userRepository.GetByEmail(email);
    
    if (user != null && _userRepository.ValidatePassword(user, password))
    {
        return user;
    }
    
    return null;
}

private bool IsValidEmail(string email)
{
    var pattern = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";
    return Regex.IsMatch(email, pattern);
}
```

---

## 65. 🔴🟢 로그인 성공 로깅

### Step 65.1: 테스트 추가

```csharp
[Test]
public void Login_Success_LogsInfo()
{
    // Arrange
    var user = new User { Id = 1, Email = "test@test.com" };
    
    _mockUserRepo.Setup(x => x.GetByEmail("test@test.com")).Returns(user);
    _mockUserRepo.Setup(x => x.ValidatePassword(user, "password123")).Returns(true);
    
    // Act
    _loginService.Login("test@test.com", "password123");
    
    // Assert
    _mockLogger.Verify(
        x => x.LogInfo(It.Is<string>(s => s.Contains("로그인 성공"))),
        Times.Once);
}
```

### Step 65.2: 코드 수정

```csharp
public User Login(string email, string password)
{
    ValidateInput(email, password);
    
    var user = _userRepository.GetByEmail(email);
    
    if (user != null && _userRepository.ValidatePassword(user, password))
    {
        _logger.LogInfo($"로그인 성공: {email}");
        return user;
    }
    
    _logger.LogWarning($"로그인 실패: {email}");
    return null;
}

private void ValidateInput(string email, string password)
{
    if (string.IsNullOrWhiteSpace(email))
        throw new ArgumentException("이메일은 필수입니다.", nameof(email));
    
    if (string.IsNullOrWhiteSpace(password))
        throw new ArgumentException("비밀번호는 필수입니다.", nameof(password));
    
    if (!IsValidEmail(email))
        throw new ArgumentException("올바른 이메일 형식이 아닙니다.", nameof(email));
}
```

---

## 66. 🔴🟢 로그인 실패 로깅

### Step 66.1: 테스트 추가

```csharp
[Test]
public void Login_Failure_LogsWarning()
{
    // Arrange
    _mockUserRepo.Setup(x => x.GetByEmail("test@test.com")).Returns((User)null);
    
    // Act
    _loginService.Login("test@test.com", "password123");
    
    // Assert
    _mockLogger.Verify(
        x => x.LogWarning(It.Is<string>(s => s.Contains("로그인 실패"))),
        Times.Once);
}
```

---

## 67. 🔵 REFACTOR: LoginService 정리

### Step 67.1: 최종 LoginService

```csharp
using System;
using System.Text.RegularExpressions;

namespace LoginSystem
{
    public class LoginService
    {
        private readonly IUserRepository _userRepository;
        private readonly ILogger _logger;
        
        private const int MinPasswordLength = 6;
        private static readonly Regex EmailRegex = new Regex(
            @"^[^@\s]+@[^@\s]+\.[^@\s]+$", 
            RegexOptions.Compiled);
        
        public LoginService(IUserRepository userRepository, ILogger logger)
        {
            _userRepository = userRepository ?? throw new ArgumentNullException(nameof(userRepository));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }
        
        public User Login(string email, string password)
        {
            ValidateInput(email, password);
            
            _logger.LogInfo($"로그인 시도: {email}");
            
            var user = _userRepository.GetByEmail(email);
            
            if (user == null)
            {
                _logger.LogWarning($"로그인 실패 - 사용자 없음: {email}");
                return null;
            }
            
            if (!_userRepository.ValidatePassword(user, password))
            {
                _logger.LogWarning($"로그인 실패 - 비밀번호 불일치: {email}");
                return null;
            }
            
            _logger.LogInfo($"로그인 성공: {email}");
            return user;
        }
        
        private void ValidateInput(string email, string password)
        {
            if (string.IsNullOrWhiteSpace(email))
                throw new ArgumentException("이메일은 필수입니다.", nameof(email));
            
            if (string.IsNullOrWhiteSpace(password))
                throw new ArgumentException("비밀번호는 필수입니다.", nameof(password));
            
            if (!EmailRegex.IsMatch(email))
                throw new ArgumentException("올바른 이메일 형식이 아닙니다.", nameof(email));
            
            if (password.Length < MinPasswordLength)
                throw new ArgumentException(
                    $"비밀번호는 최소 {MinPasswordLength}자 이상이어야 합니다.", 
                    nameof(password));
        }
    }
}
```

---

## 68. 전체 테스트 코드

### Step 68.1: LoginServiceTests.cs

```csharp
using System;
using Moq;
using NUnit.Framework;

namespace LoginSystem.Tests
{
    [TestFixture]
    public class LoginServiceTests
    {
        private Mock<IUserRepository> _mockUserRepo;
        private Mock<ILogger> _mockLogger;
        private LoginService _loginService;
        
        [SetUp]
        public void SetUp()
        {
            _mockUserRepo = new Mock<IUserRepository>();
            _mockLogger = new Mock<ILogger>();
            _loginService = new LoginService(_mockUserRepo.Object, _mockLogger.Object);
        }
        
        #region 성공 케이스
        
        [Test]
        public void Login_ValidCredentials_ReturnsUser()
        {
            // Arrange
            var expectedUser = new User { Id = 1, Email = "test@test.com" };
            _mockUserRepo.Setup(x => x.GetByEmail("test@test.com")).Returns(expectedUser);
            _mockUserRepo.Setup(x => x.ValidatePassword(expectedUser, "password123")).Returns(true);
            
            // Act
            var result = _loginService.Login("test@test.com", "password123");
            
            // Assert
            Assert.IsNotNull(result);
            Assert.AreEqual("test@test.com", result.Email);
        }
        
        [Test]
        public void Login_Success_LogsInfo()
        {
            // Arrange
            var user = new User { Id = 1, Email = "test@test.com" };
            _mockUserRepo.Setup(x => x.GetByEmail("test@test.com")).Returns(user);
            _mockUserRepo.Setup(x => x.ValidatePassword(user, "password123")).Returns(true);
            
            // Act
            _loginService.Login("test@test.com", "password123");
            
            // Assert
            _mockLogger.Verify(x => x.LogInfo(It.Is<string>(s => s.Contains("성공"))), Times.Once);
        }
        
        #endregion
        
        #region 실패 케이스
        
        [Test]
        public void Login_InvalidEmail_ReturnsNull()
        {
            _mockUserRepo.Setup(x => x.GetByEmail("wrong@test.com")).Returns((User)null);
            
            var result = _loginService.Login("wrong@test.com", "password123");
            
            Assert.IsNull(result);
        }
        
        [Test]
        public void Login_WrongPassword_ReturnsNull()
        {
            var user = new User { Id = 1, Email = "test@test.com" };
            _mockUserRepo.Setup(x => x.GetByEmail("test@test.com")).Returns(user);
            _mockUserRepo.Setup(x => x.ValidatePassword(user, "wrong")).Returns(false);
            
            var result = _loginService.Login("test@test.com", "wrong1");
            
            Assert.IsNull(result);
        }
        
        [Test]
        public void Login_Failure_LogsWarning()
        {
            _mockUserRepo.Setup(x => x.GetByEmail("test@test.com")).Returns((User)null);
            
            _loginService.Login("test@test.com", "password123");
            
            _mockLogger.Verify(x => x.LogWarning(It.IsAny<string>()), Times.Once);
        }
        
        #endregion
        
        #region 입력 검증
        
        [TestCase("")]
        [TestCase(null)]
        [TestCase("   ")]
        public void Login_EmptyEmail_ThrowsArgumentException(string email)
        {
            Assert.Throws<ArgumentException>(() => 
                _loginService.Login(email, "password123"));
        }
        
        [TestCase("")]
        [TestCase(null)]
        [TestCase("   ")]
        public void Login_EmptyPassword_ThrowsArgumentException(string password)
        {
            Assert.Throws<ArgumentException>(() => 
                _loginService.Login("test@test.com", password));
        }
        
        [TestCase("notanemail")]
        [TestCase("missing@")]
        [TestCase("@nodomain.com")]
        public void Login_InvalidEmailFormat_ThrowsArgumentException(string email)
        {
            Assert.Throws<ArgumentException>(() => 
                _loginService.Login(email, "password123"));
        }
        
        [TestCase("12345")]
        [TestCase("abc")]
        public void Login_ShortPassword_ThrowsArgumentException(string password)
        {
            Assert.Throws<ArgumentException>(() => 
                _loginService.Login("test@test.com", password));
        }
        
        #endregion
    }
}
```

---

# Part 8: TDD 안티패턴과 베스트 프랙티스

---

## 69. TDD 안티패턴

### Step 69.1: 피해야 할 패턴들

```
┌────────────────────────────────────────────────────────────────┐
│  TDD 안티패턴 (피해야 할 것들)                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 테스트 없이 코드 작성                                      │
│  ───────────────────────────────────────────────────────────  │
│  ❌ "일단 코드 먼저 짜고, 나중에 테스트 추가하자"              │
│  ✅ 테스트 먼저, 코드는 나중에                                 │
│                                                                │
│  2. 너무 큰 단계                                               │
│  ───────────────────────────────────────────────────────────  │
│  ❌ 한 번에 여러 기능 테스트/구현                              │
│  ✅ 작은 단계로 하나씩                                         │
│                                                                │
│  3. 테스트가 구현에 의존                                       │
│  ───────────────────────────────────────────────────────────  │
│  ❌ private 메서드 직접 테스트                                 │
│  ✅ public 인터페이스만 테스트                                 │
│                                                                │
│  4. 리팩토링 건너뛰기                                          │
│  ───────────────────────────────────────────────────────────  │
│  ❌ GREEN 후 바로 다음 기능으로                                │
│  ✅ 반드시 REFACTOR 단계 거치기                                │
│                                                                │
│  5. 테스트 간 의존성                                           │
│  ───────────────────────────────────────────────────────────  │
│  ❌ 테스트 A가 실행되어야 테스트 B 통과                        │
│  ✅ 각 테스트는 독립적으로                                     │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 69.2: 테스트 냄새 (Test Smells)

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 냄새 (Test Smells)                                     │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 거대한 테스트 (Giant Test)                                 │
│     • 하나의 테스트에서 너무 많은 것 검증                     │
│     → 테스트를 분리하세요                                     │
│                                                                │
│  2. 느린 테스트 (Slow Test)                                    │
│     • 실제 DB, 네트워크 사용                                  │
│     → Mock 사용하세요                                         │
│                                                                │
│  3. 깨지기 쉬운 테스트 (Fragile Test)                          │
│     • 작은 변경에도 테스트 실패                               │
│     → 구현이 아닌 동작을 테스트하세요                         │
│                                                                │
│  4. 중복 테스트 (Duplicate Test)                               │
│     • 같은 것을 여러 번 테스트                                │
│     → 테스트를 합치거나 제거하세요                            │
│                                                                │
│  5. 주석 처리된 테스트 (Commented Test)                        │
│     • // 나중에 고치기                                        │
│     → 고치거나 삭제하세요                                     │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 70. TDD 베스트 프랙티스

### Step 70.1: 따라야 할 지침

```
┌────────────────────────────────────────────────────────────────┐
│  TDD 베스트 프랙티스                                           │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 가장 간단한 케이스부터 시작                                │
│  ───────────────────────────────────────────────────────────  │
│  예: 빈 문자열 → 숫자 하나 → 숫자 두 개 → ...                │
│                                                                │
│  2. 한 번에 하나의 실패만                                      │
│  ───────────────────────────────────────────────────────────  │
│  컴파일 에러 또는 Assert 실패 중 하나만                        │
│                                                                │
│  3. 명확한 테스트 이름                                         │
│  ───────────────────────────────────────────────────────────  │
│  [메서드]_[시나리오]_[예상결과]                                │
│                                                                │
│  4. AAA 패턴 준수                                              │
│  ───────────────────────────────────────────────────────────  │
│  Arrange → Act → Assert                                       │
│                                                                │
│  5. 테스트당 하나의 Assert                                     │
│  ───────────────────────────────────────────────────────────  │
│  (관련된 Assert는 예외)                                        │
│                                                                │
│  6. 테스트도 리팩토링                                          │
│  ───────────────────────────────────────────────────────────  │
│  테스트 코드도 프로덕션 코드만큼 중요                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 71. 테스트 우선순위

### Step 71.1: 어떤 테스트를 먼저?

```
┌────────────────────────────────────────────────────────────────┐
│  테스트 우선순위                                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  높은 우선순위 (먼저 테스트)                                   │
│  ─────────────────────────────────────────────────────────────│
│  1. 핵심 비즈니스 로직                                         │
│  2. 자주 변경되는 코드                                         │
│  3. 버그가 많았던 영역                                         │
│  4. 복잡한 로직                                                │
│                                                                │
│  낮은 우선순위 (나중에 또는 생략)                              │
│  ─────────────────────────────────────────────────────────────│
│  1. 단순한 getter/setter                                       │
│  2. UI 레이아웃                                                │
│  3. 외부 라이브러리 래퍼                                       │
│  4. 일회성 스크립트                                            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 72. 효과적인 테스트 작성 팁

### Step 72.1: 실용적인 팁

```
┌────────────────────────────────────────────────────────────────┐
│  효과적인 테스트 작성 팁                                       │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 테스트 데이터는 의미 있게                                  │
│  ───────────────────────────────────────────────────────────  │
│  ❌ Add(1, 1)  // 왜 1인지 모름                                │
│  ✅ Add(orderPrice, tax)  // 의도가 명확                       │
│                                                                │
│  2. 매직 넘버 피하기                                           │
│  ───────────────────────────────────────────────────────────  │
│  ❌ Assert.AreEqual(5, result);                                │
│  ✅ var expectedSum = firstNumber + secondNumber;              │
│     Assert.AreEqual(expectedSum, result);                      │
│                                                                │
│  3. 테스트 헬퍼 메서드 활용                                    │
│  ───────────────────────────────────────────────────────────  │
│  private User CreateTestUser(string email = "test@test.com")   │
│  {                                                             │
│      return new User { Email = email, ... };                   │
│  }                                                             │
│                                                                │
│  4. 테스트 카테고리 활용                                       │
│  ───────────────────────────────────────────────────────────  │
│  [Category("Integration")]                                     │
│  [Category("Slow")]                                            │
│  → 선택적으로 테스트 실행 가능                                 │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 73. TDD와 리팩토링

### Step 73.1: 안전한 리팩토링

```
┌────────────────────────────────────────────────────────────────┐
│  TDD와 리팩토링                                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  TDD의 가장 큰 장점: 자신감 있는 리팩토링                      │
│                                                                │
│  리팩토링 전:                                                  │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ 1. 모든 테스트 실행 → 통과 확인                          │ │
│  │ 2. 리팩토링할 영역 확인                                  │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  리팩토링 중:                                                  │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ 1. 작은 변경                                             │ │
│  │ 2. 테스트 실행                                           │ │
│  │ 3. 통과하면 다음 변경, 실패하면 롤백                     │ │
│  │ 4. 반복                                                  │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  리팩토링 후:                                                  │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ 1. 모든 테스트 실행 → 통과 확인                          │ │
│  │ 2. 코드 리뷰                                             │ │
│  │ 3. 커밋                                                  │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 74. 언제 TDD를 사용할까?

### Step 74.1: TDD가 효과적인 상황

```
┌────────────────────────────────────────────────────────────────┐
│  TDD가 효과적인 상황                                           │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ✅ 새로운 기능 개발                                           │
│  ✅ 버그 수정 (먼저 버그 재현 테스트 작성)                     │
│  ✅ 복잡한 비즈니스 로직                                       │
│  ✅ API/라이브러리 설계                                        │
│  ✅ 레거시 코드 리팩토링                                       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 74.2: TDD가 어려운 상황

```
┌────────────────────────────────────────────────────────────────┐
│  TDD가 어려운 상황                                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  ⚠️ 탐색적 프로토타이핑                                        │
│     → 요구사항이 명확해지면 TDD 적용                           │
│                                                                │
│  ⚠️ UI/UX 개발                                                 │
│     → 시각적 테스트 도구 활용                                  │
│                                                                │
│  ⚠️ 외부 시스템 통합                                           │
│     → 통합 테스트로 보완                                       │
│                                                                │
│  ⚠️ 성능 최적화                                                │
│     → 먼저 동작하게 만들고, 성능 테스트 추가                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 75. TDD 도입 전략

### Step 75.1: 팀에 TDD 도입하기

```
┌────────────────────────────────────────────────────────────────┐
│  TDD 도입 전략                                                 │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  단계 1: 개인 연습                                             │
│  ─────────────────────────────────────────────────────────────│
│  • Kata 연습 (문자열 계산기, FizzBuzz 등)                     │
│  • 개인 프로젝트에 적용                                       │
│                                                                │
│  단계 2: 새 기능에 적용                                        │
│  ─────────────────────────────────────────────────────────────│
│  • 레거시는 건드리지 않고                                     │
│  • 새로 추가되는 기능만 TDD                                   │
│                                                                │
│  단계 3: 버그 수정에 적용                                      │
│  ─────────────────────────────────────────────────────────────│
│  • 버그 재현 테스트 먼저 작성                                 │
│  • 테스트 통과하도록 수정                                     │
│                                                                │
│  단계 4: 점진적 확산                                           │
│  ─────────────────────────────────────────────────────────────│
│  • 성공 사례 공유                                             │
│  • 페어 프로그래밍으로 전파                                   │
│  • 코드 리뷰에서 테스트 확인                                  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

이어서 Part 4를 작성하겠습니다.
# 🔴🟢🔵 TDD 따라하기 실습 (상세 버전) - Part 4

---

# Part 9: 종합 실습 - 장바구니 시스템

---

## 76. 장바구니 요구사항

### Step 76.1: 요구사항 정의

```
┌────────────────────────────────────────────────────────────────┐
│  장바구니 시스템 요구사항                                      │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 상품 추가                                                  │
│     • 상품과 수량을 장바구니에 추가                           │
│     • 같은 상품 추가 시 수량 증가                             │
│                                                                │
│  2. 상품 제거                                                  │
│     • 특정 상품을 장바구니에서 제거                           │
│                                                                │
│  3. 수량 변경                                                  │
│     • 특정 상품의 수량 변경                                   │
│     • 수량이 0이면 상품 제거                                  │
│                                                                │
│  4. 총액 계산                                                  │
│     • 장바구니 내 모든 상품의 총액 계산                       │
│                                                                │
│  5. 할인 적용                                                  │
│     • 총액이 10만원 이상이면 10% 할인                         │
│     • 총액이 5만원 이상이면 5% 할인                           │
│                                                                │
│  6. 장바구니 비우기                                            │
│     • 모든 상품 제거                                          │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 76.2: TODO 리스트

```
┌────────────────────────────────────────────────────────────────┐
│  📝 장바구니 TODO 리스트                                       │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  기본 기능                                                     │
│  [ ] 빈 장바구니 생성                                         │
│  [ ] 상품 하나 추가                                           │
│  [ ] 같은 상품 추가 시 수량 증가                              │
│  [ ] 상품 제거                                                │
│  [ ] 수량 변경                                                │
│  [ ] 수량 0으로 변경 시 상품 제거                             │
│  [ ] 장바구니 비우기                                          │
│                                                                │
│  총액 계산                                                     │
│  [ ] 빈 장바구니 총액 = 0                                     │
│  [ ] 상품 하나 총액                                           │
│  [ ] 여러 상품 총액                                           │
│                                                                │
│  할인                                                          │
│  [ ] 5만원 미만 - 할인 없음                                   │
│  [ ] 5만원 이상 10만원 미만 - 5% 할인                         │
│  [ ] 10만원 이상 - 10% 할인                                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 77. Product 클래스

### Step 77.1: 먼저 Product 테스트

```csharp
using NUnit.Framework;

namespace ShoppingCart.Tests
{
    [TestFixture]
    public class ProductTests
    {
        [Test]
        public void Product_Create_HasCorrectProperties()
        {
            var product = new Product(1, "테스트 상품", 10000);
            
            Assert.AreEqual(1, product.Id);
            Assert.AreEqual("테스트 상품", product.Name);
            Assert.AreEqual(10000, product.Price);
        }
        
        [Test]
        public void Product_NegativePrice_ThrowsException()
        {
            Assert.Throws<ArgumentException>(() => 
                new Product(1, "테스트", -1000));
        }
    }
}
```

### Step 77.2: Product 클래스 구현

```csharp
using System;

namespace ShoppingCart
{
    public class Product
    {
        public int Id { get; }
        public string Name { get; }
        public decimal Price { get; }
        
        public Product(int id, string name, decimal price)
        {
            if (price < 0)
                throw new ArgumentException("가격은 0 이상이어야 합니다.", nameof(price));
            
            Id = id;
            Name = name ?? throw new ArgumentNullException(nameof(name));
            Price = price;
        }
    }
}
```

---

## 78. 🔴 RED: 빈 장바구니

### Step 78.1: 테스트 작성

```csharp
[TestFixture]
public class ShoppingCartTests
{
    private Cart _cart;
    
    [SetUp]
    public void SetUp()
    {
        _cart = new Cart();
    }
    
    [Test]
    public void NewCart_IsEmpty()
    {
        Assert.AreEqual(0, _cart.ItemCount);
    }
    
    [Test]
    public void NewCart_TotalIsZero()
    {
        Assert.AreEqual(0, _cart.GetTotal());
    }
}
```

---

## 79. 🟢 GREEN: Cart 클래스 생성

### Step 79.1: 최소 구현

```csharp
namespace ShoppingCart
{
    public class Cart
    {
        public int ItemCount => 0;
        
        public decimal GetTotal()
        {
            return 0;
        }
    }
}
```

---

## 80. 🔴🟢 상품 추가

### Step 80.1: 테스트

```csharp
[Test]
public void AddItem_OneProduct_ItemCountIsOne()
{
    var product = new Product(1, "테스트 상품", 10000);
    
    _cart.AddItem(product, 1);
    
    Assert.AreEqual(1, _cart.ItemCount);
}

[Test]
public void AddItem_OneProduct_TotalEqualsPrice()
{
    var product = new Product(1, "테스트 상품", 10000);
    
    _cart.AddItem(product, 1);
    
    Assert.AreEqual(10000, _cart.GetTotal());
}
```

### Step 80.2: 구현

```csharp
using System.Collections.Generic;
using System.Linq;

namespace ShoppingCart
{
    public class Cart
    {
        private readonly Dictionary<int, CartItem> _items = new Dictionary<int, CartItem>();
        
        public int ItemCount => _items.Count;
        
        public void AddItem(Product product, int quantity)
        {
            if (_items.ContainsKey(product.Id))
            {
                _items[product.Id].Quantity += quantity;
            }
            else
            {
                _items[product.Id] = new CartItem(product, quantity);
            }
        }
        
        public decimal GetTotal()
        {
            return _items.Values.Sum(item => item.Product.Price * item.Quantity);
        }
    }
    
    public class CartItem
    {
        public Product Product { get; }
        public int Quantity { get; set; }
        
        public CartItem(Product product, int quantity)
        {
            Product = product;
            Quantity = quantity;
        }
    }
}
```

---

## 81. 🔴🟢 같은 상품 추가

### Step 81.1: 테스트

```csharp
[Test]
public void AddItem_SameProductTwice_QuantityIncreases()
{
    var product = new Product(1, "테스트 상품", 10000);
    
    _cart.AddItem(product, 1);
    _cart.AddItem(product, 2);
    
    Assert.AreEqual(1, _cart.ItemCount);  // 여전히 1종류
}

[Test]
public void AddItem_SameProductTwice_TotalIsCorrect()
{
    var product = new Product(1, "테스트 상품", 10000);
    
    _cart.AddItem(product, 1);
    _cart.AddItem(product, 2);
    
    Assert.AreEqual(30000, _cart.GetTotal());  // 10000 * 3
}
```

---

## 82. 🔴🟢 상품 제거

### Step 82.1: 테스트

```csharp
[Test]
public void RemoveItem_ExistingProduct_ItemCountDecreases()
{
    var product = new Product(1, "테스트 상품", 10000);
    _cart.AddItem(product, 1);
    
    _cart.RemoveItem(product.Id);
    
    Assert.AreEqual(0, _cart.ItemCount);
}

[Test]
public void RemoveItem_NonExistingProduct_NoError()
{
    Assert.DoesNotThrow(() => _cart.RemoveItem(999));
}
```

### Step 82.2: 구현

```csharp
public void RemoveItem(int productId)
{
    _items.Remove(productId);
}
```

---

## 83. 🔴🟢 수량 변경

### Step 83.1: 테스트

```csharp
[Test]
public void UpdateQuantity_ValidQuantity_QuantityChanges()
{
    var product = new Product(1, "테스트 상품", 10000);
    _cart.AddItem(product, 1);
    
    _cart.UpdateQuantity(product.Id, 5);
    
    Assert.AreEqual(50000, _cart.GetTotal());
}

[Test]
public void UpdateQuantity_ZeroQuantity_RemovesItem()
{
    var product = new Product(1, "테스트 상품", 10000);
    _cart.AddItem(product, 1);
    
    _cart.UpdateQuantity(product.Id, 0);
    
    Assert.AreEqual(0, _cart.ItemCount);
}

[Test]
public void UpdateQuantity_NegativeQuantity_ThrowsException()
{
    var product = new Product(1, "테스트 상품", 10000);
    _cart.AddItem(product, 1);
    
    Assert.Throws<ArgumentException>(() => 
        _cart.UpdateQuantity(product.Id, -1));
}
```

### Step 83.2: 구현

```csharp
public void UpdateQuantity(int productId, int quantity)
{
    if (quantity < 0)
        throw new ArgumentException("수량은 0 이상이어야 합니다.", nameof(quantity));
    
    if (quantity == 0)
    {
        RemoveItem(productId);
        return;
    }
    
    if (_items.ContainsKey(productId))
    {
        _items[productId].Quantity = quantity;
    }
}
```

---

## 84. 🔴🟢 장바구니 비우기

### Step 84.1: 테스트

```csharp
[Test]
public void Clear_WithItems_BecomesEmpty()
{
    var product1 = new Product(1, "상품1", 10000);
    var product2 = new Product(2, "상품2", 20000);
    _cart.AddItem(product1, 1);
    _cart.AddItem(product2, 2);
    
    _cart.Clear();
    
    Assert.AreEqual(0, _cart.ItemCount);
    Assert.AreEqual(0, _cart.GetTotal());
}
```

### Step 84.2: 구현

```csharp
public void Clear()
{
    _items.Clear();
}
```

---

## 85. 🔴🟢 할인 적용

### Step 85.1: 할인 테스트

```csharp
[Test]
public void GetTotalWithDiscount_Under50000_NoDiscount()
{
    var product = new Product(1, "상품", 40000);
    _cart.AddItem(product, 1);
    
    var total = _cart.GetTotalWithDiscount();
    
    Assert.AreEqual(40000, total);
}

[Test]
public void GetTotalWithDiscount_Between50000And100000_FivePercentDiscount()
{
    var product = new Product(1, "상품", 50000);
    _cart.AddItem(product, 1);
    
    var total = _cart.GetTotalWithDiscount();
    
    Assert.AreEqual(47500, total);  // 50000 * 0.95
}

[Test]
public void GetTotalWithDiscount_Over100000_TenPercentDiscount()
{
    var product = new Product(1, "상품", 100000);
    _cart.AddItem(product, 1);
    
    var total = _cart.GetTotalWithDiscount();
    
    Assert.AreEqual(90000, total);  // 100000 * 0.90
}
```

### Step 85.2: 할인 구현

```csharp
public decimal GetTotalWithDiscount()
{
    var total = GetTotal();
    
    if (total >= 100000)
        return total * 0.90m;
    
    if (total >= 50000)
        return total * 0.95m;
    
    return total;
}
```

---

## 86. 🔵 REFACTOR: 할인 정책 분리

### Step 86.1: 할인 정책 인터페이스

```csharp
public interface IDiscountPolicy
{
    decimal ApplyDiscount(decimal total);
}

public class StandardDiscountPolicy : IDiscountPolicy
{
    public decimal ApplyDiscount(decimal total)
    {
        if (total >= 100000)
            return total * 0.90m;
        
        if (total >= 50000)
            return total * 0.95m;
        
        return total;
    }
}
```

### Step 86.2: Cart 리팩토링

```csharp
public class Cart
{
    private readonly Dictionary<int, CartItem> _items = new Dictionary<int, CartItem>();
    private readonly IDiscountPolicy _discountPolicy;
    
    public Cart() : this(new StandardDiscountPolicy()) { }
    
    public Cart(IDiscountPolicy discountPolicy)
    {
        _discountPolicy = discountPolicy;
    }
    
    // ... 기존 메서드들 ...
    
    public decimal GetTotalWithDiscount()
    {
        return _discountPolicy.ApplyDiscount(GetTotal());
    }
}
```

---

## 87. Cart 최종 코드

### Step 87.1: 완성된 Cart 클래스

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace ShoppingCart
{
    public class Cart
    {
        private readonly Dictionary<int, CartItem> _items = new Dictionary<int, CartItem>();
        private readonly IDiscountPolicy _discountPolicy;
        
        public int ItemCount => _items.Count;
        public int TotalQuantity => _items.Values.Sum(i => i.Quantity);
        
        public Cart() : this(new StandardDiscountPolicy()) { }
        
        public Cart(IDiscountPolicy discountPolicy)
        {
            _discountPolicy = discountPolicy ?? throw new ArgumentNullException(nameof(discountPolicy));
        }
        
        public void AddItem(Product product, int quantity)
        {
            if (product == null)
                throw new ArgumentNullException(nameof(product));
            
            if (quantity <= 0)
                throw new ArgumentException("수량은 1 이상이어야 합니다.", nameof(quantity));
            
            if (_items.ContainsKey(product.Id))
            {
                _items[product.Id].Quantity += quantity;
            }
            else
            {
                _items[product.Id] = new CartItem(product, quantity);
            }
        }
        
        public void RemoveItem(int productId)
        {
            _items.Remove(productId);
        }
        
        public void UpdateQuantity(int productId, int quantity)
        {
            if (quantity < 0)
                throw new ArgumentException("수량은 0 이상이어야 합니다.", nameof(quantity));
            
            if (quantity == 0)
            {
                RemoveItem(productId);
                return;
            }
            
            if (_items.ContainsKey(productId))
            {
                _items[productId].Quantity = quantity;
            }
        }
        
        public void Clear()
        {
            _items.Clear();
        }
        
        public decimal GetTotal()
        {
            return _items.Values.Sum(item => item.Product.Price * item.Quantity);
        }
        
        public decimal GetTotalWithDiscount()
        {
            return _discountPolicy.ApplyDiscount(GetTotal());
        }
        
        public IEnumerable<CartItem> GetItems()
        {
            return _items.Values.ToList();
        }
    }
}
```

---

## 88. 전체 테스트 코드

### Step 88.1: ShoppingCartTests.cs

```csharp
using System;
using NUnit.Framework;

namespace ShoppingCart.Tests
{
    [TestFixture]
    public class ShoppingCartTests
    {
        private Cart _cart;
        
        [SetUp]
        public void SetUp()
        {
            _cart = new Cart();
        }
        
        #region 빈 장바구니
        
        [Test]
        public void NewCart_IsEmpty()
        {
            Assert.AreEqual(0, _cart.ItemCount);
        }
        
        [Test]
        public void NewCart_TotalIsZero()
        {
            Assert.AreEqual(0, _cart.GetTotal());
        }
        
        #endregion
        
        #region 상품 추가
        
        [Test]
        public void AddItem_OneProduct_ItemCountIsOne()
        {
            var product = new Product(1, "테스트 상품", 10000);
            _cart.AddItem(product, 1);
            Assert.AreEqual(1, _cart.ItemCount);
        }
        
        [Test]
        public void AddItem_OneProduct_TotalEqualsPrice()
        {
            var product = new Product(1, "테스트 상품", 10000);
            _cart.AddItem(product, 1);
            Assert.AreEqual(10000, _cart.GetTotal());
        }
        
        [Test]
        public void AddItem_SameProductTwice_QuantityIncreases()
        {
            var product = new Product(1, "테스트 상품", 10000);
            _cart.AddItem(product, 1);
            _cart.AddItem(product, 2);
            Assert.AreEqual(1, _cart.ItemCount);
            Assert.AreEqual(30000, _cart.GetTotal());
        }
        
        [Test]
        public void AddItem_MultipleProducts_CountIsCorrect()
        {
            _cart.AddItem(new Product(1, "상품1", 10000), 1);
            _cart.AddItem(new Product(2, "상품2", 20000), 2);
            Assert.AreEqual(2, _cart.ItemCount);
            Assert.AreEqual(50000, _cart.GetTotal());
        }
        
        #endregion
        
        #region 상품 제거
        
        [Test]
        public void RemoveItem_ExistingProduct_ItemRemoved()
        {
            var product = new Product(1, "상품", 10000);
            _cart.AddItem(product, 1);
            _cart.RemoveItem(product.Id);
            Assert.AreEqual(0, _cart.ItemCount);
        }
        
        [Test]
        public void RemoveItem_NonExistingProduct_NoError()
        {
            Assert.DoesNotThrow(() => _cart.RemoveItem(999));
        }
        
        #endregion
        
        #region 수량 변경
        
        [Test]
        public void UpdateQuantity_ValidQuantity_QuantityChanges()
        {
            var product = new Product(1, "상품", 10000);
            _cart.AddItem(product, 1);
            _cart.UpdateQuantity(product.Id, 5);
            Assert.AreEqual(50000, _cart.GetTotal());
        }
        
        [Test]
        public void UpdateQuantity_ZeroQuantity_RemovesItem()
        {
            var product = new Product(1, "상품", 10000);
            _cart.AddItem(product, 1);
            _cart.UpdateQuantity(product.Id, 0);
            Assert.AreEqual(0, _cart.ItemCount);
        }
        
        [Test]
        public void UpdateQuantity_NegativeQuantity_ThrowsException()
        {
            var product = new Product(1, "상품", 10000);
            _cart.AddItem(product, 1);
            Assert.Throws<ArgumentException>(() => _cart.UpdateQuantity(product.Id, -1));
        }
        
        #endregion
        
        #region 장바구니 비우기
        
        [Test]
        public void Clear_WithItems_BecomesEmpty()
        {
            _cart.AddItem(new Product(1, "상품1", 10000), 1);
            _cart.AddItem(new Product(2, "상품2", 20000), 1);
            _cart.Clear();
            Assert.AreEqual(0, _cart.ItemCount);
            Assert.AreEqual(0, _cart.GetTotal());
        }
        
        #endregion
        
        #region 할인
        
        [TestCase(40000, 40000, Description = "5만원 미만 - 할인 없음")]
        [TestCase(50000, 47500, Description = "5만원 이상 - 5% 할인")]
        [TestCase(80000, 76000, Description = "8만원 - 5% 할인")]
        [TestCase(100000, 90000, Description = "10만원 이상 - 10% 할인")]
        [TestCase(200000, 180000, Description = "20만원 - 10% 할인")]
        public void GetTotalWithDiscount_AppliesCorrectDiscount(decimal price, decimal expected)
        {
            _cart.AddItem(new Product(1, "상품", price), 1);
            Assert.AreEqual(expected, _cart.GetTotalWithDiscount());
        }
        
        #endregion
    }
}
```

---

# Part 10: 정리 및 다음 단계

---

## 89. TDD 사이클 요약

### Step 89.1: Red-Green-Refactor

```
┌────────────────────────────────────────────────────────────────┐
│  TDD 사이클 최종 요약                                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│       ┌─────────────────────────────────────────────┐          │
│       │                                             │          │
│       │   🔴 RED                                    │          │
│       │   실패하는 테스트 작성                      │          │
│       │   • 아직 없는 기능에 대한 테스트           │          │
│       │   • 컴파일 에러 또는 Assert 실패           │          │
│       │                                             │          │
│       └──────────────────┬──────────────────────────┘          │
│                          │                                     │
│                          ▼                                     │
│       ┌─────────────────────────────────────────────┐          │
│       │                                             │          │
│       │   🟢 GREEN                                  │          │
│       │   테스트 통과하는 최소 코드                 │          │
│       │   • 하드코딩도 OK                          │          │
│       │   • 완벽함보다 동작을 우선                 │          │
│       │                                             │          │
│       └──────────────────┬──────────────────────────┘          │
│                          │                                     │
│                          ▼                                     │
│       ┌─────────────────────────────────────────────┐          │
│       │                                             │          │
│       │   🔵 REFACTOR                               │          │
│       │   코드 개선 (테스트는 여전히 통과)          │          │
│       │   • 중복 제거                              │          │
│       │   • 네이밍 개선                            │          │
│       │   • 구조 개선                              │          │
│       │                                             │          │
│       └──────────────────┬──────────────────────────┘          │
│                          │                                     │
│                          └──────────► 다음 테스트로...         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 90. 학습 체크리스트

### Step 90.1: 완료 항목 확인

```
┌────────────────────────────────────────────────────────────────┐
│  ✅ 학습 완료 체크리스트                                       │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  TDD 개념                                                      │
│  ☑ TDD 정의와 철학 이해                                       │
│  ☑ Red-Green-Refactor 사이클 이해                             │
│  ☑ TDD vs 전통적 개발 비교                                    │
│  ☑ TDD의 장단점 이해                                          │
│  ☑ TDD 세 가지 법칙 이해                                      │
│  ☑ FIRST 원칙 이해                                            │
│                                                                │
│  실습                                                          │
│  ☑ 기본 계산기 TDD 구현                                       │
│  ☑ 문자열 계산기 TDD 구현                                     │
│  ☑ 로그인 서비스 TDD 구현 (Mock 사용)                         │
│  ☑ 장바구니 시스템 TDD 구현                                   │
│                                                                │
│  베스트 프랙티스                                               │
│  ☑ 안티패턴 이해                                              │
│  ☑ 테스트 냄새 인식                                           │
│  ☑ 효과적인 테스트 작성법                                     │
│  ☑ TDD와 리팩토링                                             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 91. 핵심 원칙 요약

### Step 91.1: TDD 핵심 원칙

| 원칙 | 설명 |
|------|------|
| 테스트 먼저 | 코드 작성 전에 테스트 작성 |
| 작은 단계 | 한 번에 하나의 테스트만 |
| 빠른 피드백 | 자주 테스트 실행 |
| 리팩토링 필수 | GREEN 후 반드시 REFACTOR |
| 간단하게 | 테스트 통과에 필요한 최소 코드 |

---

## 92. TDD 명령어 정리

### Step 92.1: Visual Studio 단축키

| 단축키 | 기능 |
|--------|------|
| `Ctrl + R, A` | 모든 테스트 실행 |
| `Ctrl + R, T` | 현재 테스트 실행 |
| `Ctrl + R, Ctrl + A` | 모든 테스트 디버그 |
| `Ctrl + E, T` | 테스트 탐색기 열기 |

### Step 92.2: dotnet CLI

| 명령어 | 기능 |
|--------|------|
| `dotnet test` | 테스트 실행 |
| `dotnet test --filter "Name"` | 특정 테스트만 실행 |
| `dotnet test --logger "console;verbosity=detailed"` | 상세 결과 출력 |

---

## 93. 추천 TDD 연습 문제 (Kata)

### Step 93.1: 초급

```
┌────────────────────────────────────────────────────────────────┐
│  TDD Kata - 초급                                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. FizzBuzz                                                   │
│     • 1~100 숫자 출력                                         │
│     • 3의 배수면 "Fizz"                                       │
│     • 5의 배수면 "Buzz"                                       │
│     • 15의 배수면 "FizzBuzz"                                  │
│                                                                │
│  2. 소수 판별기                                                │
│     • 주어진 숫자가 소수인지 판별                             │
│                                                                │
│  3. 로마 숫자 변환                                             │
│     • 아라비아 숫자 → 로마 숫자                               │
│     • 예: 4 → "IV", 9 → "IX"                                  │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Step 93.2: 중급

```
┌────────────────────────────────────────────────────────────────┐
│  TDD Kata - 중급                                               │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 볼링 게임 점수 계산                                        │
│     • 스트라이크, 스페어 처리                                 │
│     • 10프레임 보너스 처리                                    │
│                                                                │
│  2. 자판기                                                     │
│     • 동전 투입, 상품 선택                                    │
│     • 잔돈 반환, 재고 관리                                    │
│                                                                │
│  3. 포커 손 판별기                                             │
│     • 카드 5장의 족보 판별                                    │
│     • 원페어, 투페어, 스트레이트 등                           │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 94. 추천 학습 자료

### Step 94.1: 도서

```
┌────────────────────────────────────────────────────────────────┐
│  추천 도서                                                     │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  📚 Test-Driven Development: By Example                        │
│     - Kent Beck (TDD 창시자)                                  │
│     - TDD의 바이블                                            │
│                                                                │
│  📚 Clean Code                                                 │
│     - Robert C. Martin                                        │
│     - 테스트와 클린 코드                                      │
│                                                                │
│  📚 Growing Object-Oriented Software, Guided by Tests          │
│     - Steve Freeman, Nat Pryce                                │
│     - 실전 TDD 가이드                                         │
│                                                                │
│  📚 The Art of Unit Testing                                    │
│     - Roy Osherove                                            │
│     - 단위 테스트 심화                                        │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 95. 다음 단계

### Step 95.1: 학습 로드맵

```
┌────────────────────────────────────────────────────────────────┐
│  🎯 다음 단계 학습 권장                                        │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. BDD (Behavior-Driven Development)                          │
│     • Given-When-Then 패턴                                    │
│     • SpecFlow 프레임워크                                     │
│                                                                │
│  2. ATDD (Acceptance Test-Driven Development)                  │
│     • 인수 테스트 먼저 작성                                   │
│     • 사용자 스토리 기반 테스트                               │
│                                                                │
│  3. 테스트 커버리지 분석                                       │
│     • Coverlet + ReportGenerator                              │
│     • 커버리지 목표 설정                                      │
│                                                                │
│  4. CI/CD 파이프라인 구축                                      │
│     • GitHub Actions 연동                                     │
│     • 자동 테스트 실행                                        │
│                                                                │
│  5. 레거시 코드에 TDD 적용                                     │
│     • Characterization Test                                   │
│     • 점진적 리팩토링                                         │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

# 🎉 축하합니다!

TDD (Test-Driven Development) 실습을 완료했습니다!

이제 여러분은:
- **Red-Green-Refactor** 사이클을 이해하고 적용할 수 있습니다
- **테스트 먼저** 작성하는 개발 방식을 실천할 수 있습니다
- **작은 단계**로 점진적으로 개발할 수 있습니다
- TDD의 **장단점**을 이해하고 적절히 활용할 수 있습니다

실제 프로젝트에서 TDD를 연습하며 숙달하세요!

```
"테스트 없는 코드는 레거시 코드다." - Michael Feathers
```

---

**수고하셨습니다! 🎉**
